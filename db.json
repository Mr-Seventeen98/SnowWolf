{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","path":"icons/favicon-16x16.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","path":"icons/favicon-32x32.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/404.1a6cd5bd.css","path":"static/css/404.1a6cd5bd.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/about.32dfa3b0.css","path":"static/css/about.32dfa3b0.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/app.0d31776f.css","path":"static/css/app.0d31776f.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/categories.10e2be12.css","path":"static/css/categories.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/archives.c0d49bd5.css","path":"static/css/archives.c0d49bd5.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/chunk-libs.eebac533.css","path":"static/css/chunk-libs.eebac533.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/page.749ad047.css","path":"static/css/page.749ad047.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/post.9f951a60.css","path":"static/css/post.9f951a60.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/result.10e2be12.css","path":"static/css/result.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/tags.10e2be12.css","path":"static/css/tags.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/img/default-cover.df7c128c.jpg","path":"static/img/default-cover.df7c128c.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/404.00d640a8.js","path":"static/js/404.00d640a8.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/about.024aacd1.js","path":"static/js/about.024aacd1.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/app.6d2c358d.js","path":"static/js/app.6d2c358d.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/archives.574ac664.js","path":"static/js/archives.574ac664.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/categories.90aa5475.js","path":"static/js/categories.90aa5475.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/chunk-libs.dc6146cd.js","path":"static/js/chunk-libs.dc6146cd.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/page.a02618ad.js","path":"static/js/page.a02618ad.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/result.39470350.js","path":"static/js/result.39470350.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/post.cebfbaa4.js","path":"static/js/post.cebfbaa4.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/tags.2ad613f5.js","path":"static/js/tags.2ad613f5.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"c024f992aafcc034b7c51ae8dd7d2f89c2313b6a","modified":1637595167098},{"_id":"source/about/index.md","hash":"5480fae43dd13e0f48ce8aece4d7b7811e7f0790","modified":1637593534403},{"_id":"node_modules/hexo-theme-aurora/.browserslistrc","hash":"db215b841182d2af3259a1c1d6e1957bca333970","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/CHANGELOG.md","hash":"e68f3af8af17d326a48e1b317e01d7429193217e","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/CHANGELOG_CN.md","hash":"5d13c251e8b77fd86870da50f3be98f8822edc66","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/LICENSE","hash":"21cf269018b0cf04e1126b6b9b1a5e6af7c5e61f","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/README.md","hash":"c50f58b08b75780990c18ab85761e3e24aac0d90","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/_config.yml","hash":"e6b2335cb393444b8a1fc1ad65331f4a30bc8915","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/jest.config.js","hash":"425f08cb718a56630ce61ae0686f35c55ef565df","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/package.json","hash":"366469094f0ca671c96bcb904f4b4f3481170135","modified":1637593188484},{"_id":"node_modules/hexo-theme-aurora/.circleci/config.yml","hash":"534051be311581f69aa8287120275a04539290e4","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/data/en.yml","hash":"7bbd6c0da0ae2f93f8a786a3be77fbe4e95a787e","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/data/cn.yml","hash":"4f5dcc1e2953df7a8e4e683c1a9115f6e0041f5e","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/layout/index.ejs","hash":"94732830a65b718d2fa506b8598df44f14399fd8","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/index.js","hash":"2a3c62a860581ee6813ca4bcaa7c952f614e818c","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/filters/index.js","hash":"5eacff9446dd6c9a7eb0a0c84be9187055440454","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/category.js","hash":"0ae21ffcf6e471ebfb72ac62a833991fae86ec8a","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/index.js","hash":"dfbb0fdbf990bd67684ed891a4aaa1fd8dcd23f2","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/page.js","hash":"1be54ea9cdf8e293e67bf457075fcdd8a72b8779","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/post.js","hash":"76c3268e8b6887fb1fd11c4d71004aad9dc215fc","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/site.js","hash":"b5f5ce813b4b0b322eceb11b036dc65201604256","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/search.js","hash":"a2a636e1df76efdcaca37226b490afa539ce766b","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/statistic.js","hash":"1c641956e15cec96490de16a88ccc7bec0c9d5c4","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/generators/tag.js","hash":"975e79e73d2503a33dbc63655b948100cc46d44f","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/injector/index.js","hash":"7ca562ea3af3068ee925b5a8afdce0eaa1e15e64","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/mapper.js","hash":"7a99508d910321b90b4afa0df02ad90f62336901","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/symbols-count-time.js","hash":"d1a81e31b2988edcdf4b4761cec7326a980f097a","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/truncate-html.js","hash":"49d4832af027eabe5b8383a24e66dceae761533e","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/toc.js","hash":"5c7348c550ef7f164d492847801a360cdefc60a2","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/scripts/lib/helpers/utils.js","hash":"93ff75f0e35a1dc40d5406cc097f5988dd820600","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/css/app.0d31776f.css","hash":"43b43acd76bd8dc22f34cc49c7e026c45c3a5004","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/chunk-libs.dc6146cd.js","hash":"534266637d09abf39278f4d3a21bd36728740105","modified":499162500000},{"_id":"node_modules/hexo-theme-aurora/source/static/js/app.6d2c358d.js","hash":"e176c20c22ce36e38935f463977e9b89b281c715","modified":499162500000},{"_id":"public/api/posts/1.json","hash":"aea41c3925da78001bf4dec0c2e2a6edaeef6248","modified":1637595006934},{"_id":"public/api/articles/hello-world.json","hash":"718e499506d982268add8a2ac7bf957e8e28e98b","modified":1637595006934},{"_id":"public/api/features.json","hash":"97d170e1550eee4afc0af065b78cda302a97674c","modified":1637595006934},{"_id":"public/api/authors/blog-author.json","hash":"c8fff1d8aee8430c93f24a0accda7a231220dcbf","modified":1637595006934},{"_id":"public/api/site.json","hash":"784b3d73b541600c4f7122db5183dbbd943ae909","modified":1637595006934},{"_id":"public/api/tags.json","hash":"97d170e1550eee4afc0af065b78cda302a97674c","modified":1637595006934},{"_id":"public/api/categories.json","hash":"97d170e1550eee4afc0af065b78cda302a97674c","modified":1637595006934},{"_id":"public/api/pages/about/index.json","hash":"490a215cd64b4e6d590c8e48e91bdc0ae95ec806","modified":1637595006934},{"_id":"public/api/statistic.json","hash":"5464b602b9026f02c9c2ba4466e3849be68de844","modified":1637595006934},{"_id":"public/api/search.json","hash":"01bce2cc87286fdd2cd470fc9134a81216a20bab","modified":1637595006934},{"_id":"public/index.html","hash":"09970345a3a999b38499f32011d885bbb6c4c8d7","modified":1637595006934},{"_id":"public/:/post/hello-world.html","hash":"09970345a3a999b38499f32011d885bbb6c4c8d7","modified":1637595006934},{"_id":"public/tags/index.html","hash":"09970345a3a999b38499f32011d885bbb6c4c8d7","modified":1637595006934},{"_id":"public/archives/index.html","hash":"09970345a3a999b38499f32011d885bbb6c4c8d7","modified":1637595006934},{"_id":"public/page/about/index.html","hash":"09970345a3a999b38499f32011d885bbb6c4c8d7","modified":1637595006934},{"_id":"public/tags/search/index.html","hash":"09970345a3a999b38499f32011d885bbb6c4c8d7","modified":1637595006934},{"_id":"public/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1637595006934},{"_id":"public/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1637595006934},{"_id":"public/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1637595006934},{"_id":"public/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1637595006934},{"_id":"public/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":1637595006934},{"_id":"public/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1637595006934},{"_id":"public/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":1637595006934},{"_id":"public/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":1637595006934},{"_id":"public/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":1637595006934},{"_id":"public/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":1637595006934},{"_id":"public/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":1637595006934},{"_id":"public/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1637595006934},{"_id":"public/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1637595006934},{"_id":"public/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":1637595006934},{"_id":"public/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":1637595006934},{"_id":"public/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":1637595006934},{"_id":"public/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":1637595006934},{"_id":"public/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":1637595006934},{"_id":"public/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":1637595006934},{"_id":"public/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":1637595006934},{"_id":"public/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":1637595006934},{"_id":"source/ng-pwa/index.md","hash":"e6400de2b9724d4676e56ecdb000e183a784408a","modified":1637595319870},{"_id":"source/_posts/ng-pwa.md","hash":"e6400de2b9724d4676e56ecdb000e183a784408a","modified":1637595512002},{"_id":"source/_posts/eventLoop.md","hash":"cbbac4a2fa167857290387f70fdc108a848c02b1","modified":1637597410391}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2021-11-22T15:05:34.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-11-22 23:05:34\n---\n","updated":"2021-11-22T15:05:34.403Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckwatsajh0000e0vj7p5ma7xn","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"使用 Cloudflare Pages 部署网站","date":"2021-11-14T13:04:34.000Z","_content":"\n使用 Cloudflare Pages 从 GitHub 帐户直接部署前端应用。\n在开始使用 Cloudflare Pages，并将网站部署到 Pages 平台前需要先创建一个 [Cloudflare 账户](https://dash.cloudflare.com/sign-up)\n\n## 目录\n\n- 连接 GitHub 帐户\n- 配置和部署\n\n### 连接 GitHub 帐户\n\n#### 登录 Cloudflare Pages\n首先，打开[Cloudflare Pages](https://pages.cloudflare.com/) 站点管理并使用 Cloudflare 帐户登录。如果还没有帐户，需要先进行注册。\n\n#### GitHub授权\n在`Cloudflare Pages`页面中选择`创建项目`并将`GitHub`账户添加进来。添加完成后在页面中可以看到`GitHub`的存储库\n![1](http://jsnext.icu/20211114212219.png)\n\n### 配置和部署\n\n#### 选择 GitHub 存储库\n可以从个人帐户或授予 `Pages` 访问权限的组织中选择一个 `GitHub` 项目。允许选择一个 `GitHub` 存储库使用 `Pages` 进行部署。支持私有和公共存储库。\n\n#### 基础配置\n选择存储库后，选择`Install & Authorize and Begin setup`。然后，可以在设置构建和部署页面中自定义部署参数。\n\n项目名称：用于生成访问页面的域名，默认值与`GitHub`项目名称相同\n\n分支：Cloudflare Pages 应用于部署站点的版本分支\n![2](http://jsnext.icu/20211114213047.png)\n\n#### 构建配置\n根据需要部署到 Cloudflare Pages 项目的 `框架`，需要指定站点的构建`命令`和`输出目录`，从而告诉 Cloudflare Pages 如何部署站点。输出目录的内容作为需要上传到 Cloudflare Pages。配置完成后点击`保存并部署`。\n`根据项目框架的不同可能有些环境需要有单独的配置，例如构建ng13的项目所依赖的node版本必须14+以上`\n![3](http://jsnext.icu/20211114213901.png)\n\n在部署的过程中，可以看到控制台的一些输出(这里有可能会报错，根据控制台的error信息自行处理即可)。编译和部署完后可以看到以下结果。\n![4](http://jsnext.icu/20211114214001.png)\n\n在回到pages页面可以看到已经部署好的网站\n![5](http://jsnext.icu/20211114214448.png)","source":"_posts/hello-world.md","raw":"---\ntitle: 使用 Cloudflare Pages 部署网站\ndate: 2021-11-14 21:04:34\ntags:\n---\n\n使用 Cloudflare Pages 从 GitHub 帐户直接部署前端应用。\n在开始使用 Cloudflare Pages，并将网站部署到 Pages 平台前需要先创建一个 [Cloudflare 账户](https://dash.cloudflare.com/sign-up)\n\n## 目录\n\n- 连接 GitHub 帐户\n- 配置和部署\n\n### 连接 GitHub 帐户\n\n#### 登录 Cloudflare Pages\n首先，打开[Cloudflare Pages](https://pages.cloudflare.com/) 站点管理并使用 Cloudflare 帐户登录。如果还没有帐户，需要先进行注册。\n\n#### GitHub授权\n在`Cloudflare Pages`页面中选择`创建项目`并将`GitHub`账户添加进来。添加完成后在页面中可以看到`GitHub`的存储库\n![1](http://jsnext.icu/20211114212219.png)\n\n### 配置和部署\n\n#### 选择 GitHub 存储库\n可以从个人帐户或授予 `Pages` 访问权限的组织中选择一个 `GitHub` 项目。允许选择一个 `GitHub` 存储库使用 `Pages` 进行部署。支持私有和公共存储库。\n\n#### 基础配置\n选择存储库后，选择`Install & Authorize and Begin setup`。然后，可以在设置构建和部署页面中自定义部署参数。\n\n项目名称：用于生成访问页面的域名，默认值与`GitHub`项目名称相同\n\n分支：Cloudflare Pages 应用于部署站点的版本分支\n![2](http://jsnext.icu/20211114213047.png)\n\n#### 构建配置\n根据需要部署到 Cloudflare Pages 项目的 `框架`，需要指定站点的构建`命令`和`输出目录`，从而告诉 Cloudflare Pages 如何部署站点。输出目录的内容作为需要上传到 Cloudflare Pages。配置完成后点击`保存并部署`。\n`根据项目框架的不同可能有些环境需要有单独的配置，例如构建ng13的项目所依赖的node版本必须14+以上`\n![3](http://jsnext.icu/20211114213901.png)\n\n在部署的过程中，可以看到控制台的一些输出(这里有可能会报错，根据控制台的error信息自行处理即可)。编译和部署完后可以看到以下结果。\n![4](http://jsnext.icu/20211114214001.png)\n\n在回到pages页面可以看到已经部署好的网站\n![5](http://jsnext.icu/20211114214448.png)","slug":"hello-world","published":1,"updated":"2021-11-22T15:32:47.098Z","_id":"ckwatsajn0001e0vj0rmn9949","comments":1,"layout":"post","photos":[],"link":"","content":"<p>使用 Cloudflare Pages 从 GitHub 帐户直接部署前端应用。<br>在开始使用 Cloudflare Pages，并将网站部署到 Pages 平台前需要先创建一个 <a href=\"https://dash.cloudflare.com/sign-up\">Cloudflare 账户</a></p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li>连接 GitHub 帐户</li>\n<li>配置和部署</li>\n</ul>\n<h3 id=\"连接-GitHub-帐户\"><a href=\"#连接-GitHub-帐户\" class=\"headerlink\" title=\"连接 GitHub 帐户\"></a>连接 GitHub 帐户</h3><h4 id=\"登录-Cloudflare-Pages\"><a href=\"#登录-Cloudflare-Pages\" class=\"headerlink\" title=\"登录 Cloudflare Pages\"></a>登录 Cloudflare Pages</h4><p>首先，打开<a href=\"https://pages.cloudflare.com/\">Cloudflare Pages</a> 站点管理并使用 Cloudflare 帐户登录。如果还没有帐户，需要先进行注册。</p>\n<h4 id=\"GitHub授权\"><a href=\"#GitHub授权\" class=\"headerlink\" title=\"GitHub授权\"></a>GitHub授权</h4><p>在<code>Cloudflare Pages</code>页面中选择<code>创建项目</code>并将<code>GitHub</code>账户添加进来。添加完成后在页面中可以看到<code>GitHub</code>的存储库<br><img src=\"http://jsnext.icu/20211114212219.png\" alt=\"1\"></p>\n<h3 id=\"配置和部署\"><a href=\"#配置和部署\" class=\"headerlink\" title=\"配置和部署\"></a>配置和部署</h3><h4 id=\"选择-GitHub-存储库\"><a href=\"#选择-GitHub-存储库\" class=\"headerlink\" title=\"选择 GitHub 存储库\"></a>选择 GitHub 存储库</h4><p>可以从个人帐户或授予 <code>Pages</code> 访问权限的组织中选择一个 <code>GitHub</code> 项目。允许选择一个 <code>GitHub</code> 存储库使用 <code>Pages</code> 进行部署。支持私有和公共存储库。</p>\n<h4 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h4><p>选择存储库后，选择<code>Install &amp; Authorize and Begin setup</code>。然后，可以在设置构建和部署页面中自定义部署参数。</p>\n<p>项目名称：用于生成访问页面的域名，默认值与<code>GitHub</code>项目名称相同</p>\n<p>分支：Cloudflare Pages 应用于部署站点的版本分支<br><img src=\"http://jsnext.icu/20211114213047.png\" alt=\"2\"></p>\n<h4 id=\"构建配置\"><a href=\"#构建配置\" class=\"headerlink\" title=\"构建配置\"></a>构建配置</h4><p>根据需要部署到 Cloudflare Pages 项目的 <code>框架</code>，需要指定站点的构建<code>命令</code>和<code>输出目录</code>，从而告诉 Cloudflare Pages 如何部署站点。输出目录的内容作为需要上传到 Cloudflare Pages。配置完成后点击<code>保存并部署</code>。<br><code>根据项目框架的不同可能有些环境需要有单独的配置，例如构建ng13的项目所依赖的node版本必须14+以上</code><br><img src=\"http://jsnext.icu/20211114213901.png\" alt=\"3\"></p>\n<p>在部署的过程中，可以看到控制台的一些输出(这里有可能会报错，根据控制台的error信息自行处理即可)。编译和部署完后可以看到以下结果。<br><img src=\"http://jsnext.icu/20211114214001.png\" alt=\"4\"></p>\n<p>在回到pages页面可以看到已经部署好的网站<br><img src=\"http://jsnext.icu/20211114214448.png\" alt=\"5\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用 Cloudflare Pages 从 GitHub 帐户直接部署前端应用。<br>在开始使用 Cloudflare Pages，并将网站部署到 Pages 平台前需要先创建一个 <a href=\"https://dash.cloudflare.com/sign-up\">Cloudflare 账户</a></p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li>连接 GitHub 帐户</li>\n<li>配置和部署</li>\n</ul>\n<h3 id=\"连接-GitHub-帐户\"><a href=\"#连接-GitHub-帐户\" class=\"headerlink\" title=\"连接 GitHub 帐户\"></a>连接 GitHub 帐户</h3><h4 id=\"登录-Cloudflare-Pages\"><a href=\"#登录-Cloudflare-Pages\" class=\"headerlink\" title=\"登录 Cloudflare Pages\"></a>登录 Cloudflare Pages</h4><p>首先，打开<a href=\"https://pages.cloudflare.com/\">Cloudflare Pages</a> 站点管理并使用 Cloudflare 帐户登录。如果还没有帐户，需要先进行注册。</p>\n<h4 id=\"GitHub授权\"><a href=\"#GitHub授权\" class=\"headerlink\" title=\"GitHub授权\"></a>GitHub授权</h4><p>在<code>Cloudflare Pages</code>页面中选择<code>创建项目</code>并将<code>GitHub</code>账户添加进来。添加完成后在页面中可以看到<code>GitHub</code>的存储库<br><img src=\"http://jsnext.icu/20211114212219.png\" alt=\"1\"></p>\n<h3 id=\"配置和部署\"><a href=\"#配置和部署\" class=\"headerlink\" title=\"配置和部署\"></a>配置和部署</h3><h4 id=\"选择-GitHub-存储库\"><a href=\"#选择-GitHub-存储库\" class=\"headerlink\" title=\"选择 GitHub 存储库\"></a>选择 GitHub 存储库</h4><p>可以从个人帐户或授予 <code>Pages</code> 访问权限的组织中选择一个 <code>GitHub</code> 项目。允许选择一个 <code>GitHub</code> 存储库使用 <code>Pages</code> 进行部署。支持私有和公共存储库。</p>\n<h4 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h4><p>选择存储库后，选择<code>Install &amp; Authorize and Begin setup</code>。然后，可以在设置构建和部署页面中自定义部署参数。</p>\n<p>项目名称：用于生成访问页面的域名，默认值与<code>GitHub</code>项目名称相同</p>\n<p>分支：Cloudflare Pages 应用于部署站点的版本分支<br><img src=\"http://jsnext.icu/20211114213047.png\" alt=\"2\"></p>\n<h4 id=\"构建配置\"><a href=\"#构建配置\" class=\"headerlink\" title=\"构建配置\"></a>构建配置</h4><p>根据需要部署到 Cloudflare Pages 项目的 <code>框架</code>，需要指定站点的构建<code>命令</code>和<code>输出目录</code>，从而告诉 Cloudflare Pages 如何部署站点。输出目录的内容作为需要上传到 Cloudflare Pages。配置完成后点击<code>保存并部署</code>。<br><code>根据项目框架的不同可能有些环境需要有单独的配置，例如构建ng13的项目所依赖的node版本必须14+以上</code><br><img src=\"http://jsnext.icu/20211114213901.png\" alt=\"3\"></p>\n<p>在部署的过程中，可以看到控制台的一些输出(这里有可能会报错，根据控制台的error信息自行处理即可)。编译和部署完后可以看到以下结果。<br><img src=\"http://jsnext.icu/20211114214001.png\" alt=\"4\"></p>\n<p>在回到pages页面可以看到已经部署好的网站<br><img src=\"http://jsnext.icu/20211114214448.png\" alt=\"5\"></p>\n"},{"title":"Angular Service Worker - PWA","_content":"[完整代码](https://github.com/Mr-Seventeen98/ngpwa)\n使用 Angular Service Worker 和 Angular CLI 内置的 PWA 支持，将 Web 应用程序转换成可下载和安装的移动应用程序。\n\n在此过程中，将了解 Angular Service Worker 的设计及其背后的工作原理，并了解它的工作方式与其他构建时生成 Service Worker 的不同。\n\n## 目录\n\n在这篇文章中，我们将讨论以下主题：\n\n- 使用 Angular CLI 搭建 Angular PWA 应用程序\n- 了解如何手动添加 Angular PWA 支持\n- 了解 Angular Service Worker 运行时缓存机制\n- 运行和理解 PWA 的构建\n- 在生产环境下启动 Angular PWA\n- 版本管理\n\n### 搭建 Angular PWA\n创建 Angular PWA 的第一步是将 Angular CLI 升级到最新版本：\n``` bash\nnpm install -g @angular/cli@latest\n```\n搭建一个 Angular 应用程序并添加 Angular Service Worker 相关pacakge\n``` bash\nng new angular-pwa-app\n```\n将 Angular Service Worker 添加到现有应用程序中\n`这里一定是用ng add 不能用npm i或者yarn add，因为ng add @angular/pwa 是angular cli 扩展的命令，会修改整个项目对PWA支持的文件，如果要使用 npm i 或者 yarn add的话，直接安装@angular/service-worker包，后面所有的文件改动都需要手动去修改`\n``` bash\nng add @angular/pwa\n```\n\n### 了解如何手动添加 Angular PWA 支持\n执行完第一步所有的操作后PWA的支持几乎已经被CLI处理完了。但我们需要知道它都改变了些什么，以防以后需要手动升级Angular应用或者是手动配置webpackage\n\n- @angular/service-worker包被添加到package.json. angular.json配置文件中多出了一项`\"serviceWorker\": true`\n``` json\n{\n  \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\",\n  \"cli\": {\n    \"analytics\": false\n  },\n  \"version\": 1,\n  \"newProjectRoot\": \"projects\",\n  \"projects\": {\n    \"angular-pwa-app\": {\n      \"projectType\": \"application\",\n      \"schematics\": {\n        ...\n      },\n      \"root\": \"\",\n      \"sourceRoot\": \"src\",\n      \"prefix\": \"app\",\n      \"architect\": {\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            \"outputPath\": \"dist/angular-pwa-app\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": \"src/polyfills.ts\",\n            \"tsConfig\": \"tsconfig.app.json\",\n            \"inlineStyleLanguage\": \"sass\",\n            \"assets\": [\n              ...\n            ],\n            \"styles\": [\n              \"src/styles.sass\"\n            ],\n            \"scripts\": [],\n            \"serviceWorker\": true, // 添加项\n            \"ngswConfigPath\": \"ngsw-config.json\"\n          },\n          \"configurations\": {\n            ...\n          },\n          \"defaultConfiguration\": \"production\"\n        },\n        \"serve\": {\n          ...\n        },\n        \"extract-i18n\": {\n          \"builder\": \"@angular-devkit/build-angular:extract-i18n\",\n          \"options\": {\n            \"browserTarget\": \"angular-pwa-app:build\"\n          }\n        },\n        \"test\": {\n          ...\n        }\n      }\n    }\n  },\n  \"defaultProject\": \"angular-pwa-app\"\n}\n```\n`serviceWorker` 节点有什么用途？\n将导致 `build` 后的 `dist` 文件夹中包含几个额外的文件：\n  - `ngsw-worker.js`: Angular Service Worker 文件\n  -  `ngsw.json`: Angular Service Worker 的运行时配置\n\n- 应用程序 `AppModule` 中添加了 `ServiceWorkerModule` 的注册\n```typescript\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    ServiceWorkerModule.register('ngsw-worker.js', {\n      enabled: environment.production,\n      // Register the ServiceWorker as soon as the app is stable\n      // or after 30 seconds (whichever comes first).\n      registrationStrategy: 'registerWhenStable:30000'\n    })\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n`ServiceWorkerModule` 有什么用途？\n这个模块提供了几个可注入的服务：\n  - `SwUpdate` 用于管理应用程序版本更新\n  - `SwPush` 用于执行服务器 Web 推送通知\n该模块通过调用 navigator.serviceWorker.register() 在用户浏览器中加载 ngsw-worker.js，在浏览器中注册 Angular Service Worker（浏览器支持Service Worker的情况下）。\n调用 register() 会导致 ngsw-worker.js 文件被加载到单独的 HTTP 请求中。有了这个，将我们的 Angular 应用程序转变为 PWA 只缺少一件事。\n\n- 构建配置文件 ngsw-config.json\nCLI 还添加了一个名为ngsw-config.json的配置文件，用于配置 Angular Service Worker 运行时参数，并且生成的文件带有一些默认值。\n```json\n{\n  \"$schema\": \"./node_modules/@angular/service-worker/config/schema.json\",\n  \"index\": \"/index.html\",\n  \"assetGroups\": [\n    {\n      \"name\": \"app\",\n      \"installMode\": \"prefetch\",\n      \"resources\": {\n        \"files\": [\n          \"/favicon.ico\",\n          \"/index.html\",\n          \"/manifest.webmanifest\",\n          \"/*.css\",\n          \"/*.js\"\n        ]\n      }\n    },\n    {\n      \"name\": \"assets\",\n      \"installMode\": \"lazy\",\n      \"updateMode\": \"prefetch\",\n      \"resources\": {\n        \"files\": [\n          \"/assets/**\",\n          \"/*.(svg|cur|jpg|jpeg|png|apng|webp|avif|gif|otf|ttf|woff|woff2)\"\n        ]\n      }\n    }\n  ]\n}\n```\n此文件包含默认缓存行为或 Angular Service Worker，它针对应用程序静态资产文件：index.html、CSS 和 Javascript。\n\n### Angular Service Worker 运行时缓存机制\nAngular Service Worker 可以在浏览器[CacheStorage](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage)中缓存各种内容\n\n这是一种基于Javascript的key/value缓存机制，与标准浏览器Cache-Control机制无关，两种机制可以分开使用。\n\nassetGroups配置文件部分的目标是准确配置 Angular Service Worker 在缓存存储中缓存的 HTTP 请求，并且有两个缓存配置条目：\n  - 一个名为 的条目app，用于所有单页应用程序文件（所有应用程序 index.html、CSS 和 Javascript 包以及图标）\n  - 另一个名为 的条目assets，用于也包含在 dist 文件夹中的任何其他资产，例如图像，但不一定是运行每个页面所必需的\n\n缓存静态文件是应用程序本身\n另一方面，资产文件仅在被请求时才被缓存（意味着是惰性的），但如果它们曾经被请求过一次，并且有新版本可用，那么它们将被提前下载（意味着这是预更新模式）。\n\n同样，对于在单独的 HTTP 请求中下载的任何资产（例如图像）来说，这是一个很好的策略，因为根据用户访问的页面，它们可能并不总是需要。\n\n但是如果他们需要一次，那么我们很可能也需要更新版本，所以我们不妨提前下载新版本。\n\n同样，这些是默认值，但我们可以调整它以适合我们自己的应用程序。但是，在应用程序文件的特定情况下，我们不太可能想使用其他策略。\n\n毕竟，应用缓存配置是我们正在寻找的下载和安装功能本身。也许我们使用 CLI 生成的包之外的其他文件？在这种情况下，我们希望调整我们的配置。\n\n重要的是要记住，有了这些默认设置，我们已经准备好了一个可下载和可安装的应用程序。\n\n### 运行和理解 PWA的构建\n首先向应用程序添加一些可视化内容，以清楚地标识在用户浏览器中运行的给定版本。例如，我们可以用以下内容替换app.component.html文件的内容：\n``` html\n<h1>Version V1 is runnning ...</h1>\n```\n现在让我们构建这个 PWA 应用程序。Angular Service Worker 仅在生产模式下可用，所以让我们首先对我们的应用程序进行生产构建：\n``` json\nng build --prod\n```\n\n#### 构建后的文件\n让我们看看我们的 build 文件夹中有什么，这里是生成的所有文件：\n![1](http://jsnext.icu/20211114085812.png)\n构建配置文件中的serviceWorker标志angular.json导致 Angular CLI 包含几个额外的文件\n\n#### ngsw-worker.js文件\n这个文件就是 Angular Service Worker 本身。与所有 Service Worker 一样，它通过自己单独的 HTTP 请求进行交付，以便浏览器可以跟踪它是否发生了变化，并将其应用于 Service Worker 生命周期\n\n它将ServiceWorkerModule通过调用间接触发此文件的加载navigation.serviceWorker.register()。\n\n然后，此文件将保持不变，直到您升级到包含新版本 Angular Service Worker 的新 Angular 版本。\n\n#### ngsw.json文件\n这是Angular Service Worker 将使用的运行时配置文件。该文件基于该文件构建ngsw-config.json，并包含 Angular Service Worker 在运行时了解它需要缓存哪些文件以及何时缓存所需的所有信息。\n```json\n{\n  \"configVersion\": 1,\n  \"timestamp\": 1636811800992,\n  \"index\": \"/index.html\",\n  \"assetGroups\": [\n    {\n      \"name\": \"app\",\n      \"installMode\": \"prefetch\",\n      \"updateMode\": \"prefetch\",\n      \"cacheQueryOptions\": {\n        \"ignoreVary\": true\n      },\n      \"urls\": [\n        \"/favicon.ico\",\n        \"/index.html\",\n        \"/main.9b1590cf6a3f05bd.js\",\n        \"/manifest.webmanifest\",\n        \"/polyfills.d2940b6b864d5b0c.js\",\n        \"/runtime.e6e2f4954d860551.js\",\n        \"/styles.ef46db3751d8e999.css\"\n      ],\n      \"patterns\": []\n    },\n    {\n      \"name\": \"assets\",\n      \"installMode\": \"lazy\",\n      \"updateMode\": \"prefetch\",\n      \"cacheQueryOptions\": {\n        \"ignoreVary\": true\n      },\n      \"urls\": [\n        \"/assets/icons/icon-128x128.png\",\n        \"/assets/icons/icon-144x144.png\",\n        \"/assets/icons/icon-152x152.png\",\n        \"/assets/icons/icon-192x192.png\",\n        \"/assets/icons/icon-384x384.png\",\n        \"/assets/icons/icon-512x512.png\",\n        \"/assets/icons/icon-72x72.png\",\n        \"/assets/icons/icon-96x96.png\"\n      ],\n      \"patterns\": []\n    }\n  ],\n  \"dataGroups\": [],\n  \"hashTable\": {\n    \"/assets/icons/icon-128x128.png\": \"dae3b6ed49bdaf4327b92531d4b5b4a5d30c7532\",\n    \"/assets/icons/icon-144x144.png\": \"b0bd89982e08f9bd2b642928f5391915b74799a7\",\n    \"/assets/icons/icon-152x152.png\": \"7479a9477815dfd9668d60f8b3b2fba709b91310\",\n    \"/assets/icons/icon-192x192.png\": \"1abd80d431a237a853ce38147d8c63752f10933b\",\n    \"/assets/icons/icon-384x384.png\": \"329749cd6393768d3131ed6304c136b1ca05f2fd\",\n    \"/assets/icons/icon-512x512.png\": \"559d9c4318b45a1f2b10596bbb4c960fe521dbcc\",\n    \"/assets/icons/icon-72x72.png\": \"c457e56089a36952cd67156f9996bc4ce54a5ed9\",\n    \"/assets/icons/icon-96x96.png\": \"3914125a4b445bf111c5627875fc190f560daa41\",\n    \"/favicon.ico\": \"22f6a4a3bcaafafb0254e0f2fa4ceb89e505e8b2\",\n    \"/index.html\": \"2dddde2e959d509b5875df1affbbdeeca0013ef5\",\n    \"/main.9b1590cf6a3f05bd.js\": \"a40c908f209a2e5ded532ecb14c6125fd64c6772\",\n    \"/manifest.webmanifest\": \"ccd3e1a5912adcc16f66473d4cba3e30f2bc0f04\",\n    \"/polyfills.d2940b6b864d5b0c.js\": \"48b7ab4dcc659f5bffded964098491e3504c8d66\",\n    \"/runtime.e6e2f4954d860551.js\": \"8e240156b422208604399acf6a5c744f5468a071\",\n    \"/styles.ef46db3751d8e999.css\": \"da39a3ee5e6b4b0d3255bfef95601890afd80709\"\n  },\n  \"navigationUrls\": [\n    {\n      \"positive\": true,\n      \"regex\": \"^\\\\/.*$\"\n    },\n    {\n      \"positive\": false,\n      \"regex\": \"^\\\\/(?:.+\\\\/)?[^/]*\\\\.[^/]*$\"\n    },\n    {\n      \"positive\": false,\n      \"regex\": \"^\\\\/(?:.+\\\\/)?[^/]*__[^/]*$\"\n    },\n    {\n      \"positive\": false,\n      \"regex\": \"^\\\\/(?:.+\\\\/)?[^/]*__[^/]*\\\\/.*$\"\n    }\n  ],\n  \"navigationRequestStrategy\": \"performance\"\n}\n```\n此文件是`ngsw-config.json`该文件的扩展版本，其中所有通配符 url 都已应用并替换为与之匹配的任何文件的路径。\n\n#### Angular Service Worker 如何使用ngsw.json\nAngular Service Worker 将在安装模式预取的情况下主动加载这些文件，或者在安装模式延迟的情况下根据需要加载这些文件，并且还将这些文件存储在缓存存储中\n\n此加载将在后台进行，因为用户首先加载应用程序。下次用户刷新页面时，Angular Service Worker 将拦截 HTTP 请求，并将提供缓存文件而不是从网络获取它们。\n\n每个资产在`hashTable`都有一个对应的哈希值。如果我们对此处列出的任何文件进行任何修改（即使它只有一个字符），我们将在以下 Angular CLI 构建中获得完全不同的哈希值。\n\n然后 Angular Service Worker 将知道该文件在服务器上有一个新版本，需要在适当的时间加载。\n\n### 生产环境下启动 Angular PWA\n然后让我们以生产模式启动应用程序，为此，我们需要一个小型 Web 服务器。一个不错的选择是http-server，让我们安装它：\n``` json\nnpm install -g http-server\n```\n然后让我们进入`dist/angular-pwa-app`文件夹，并以生产模式启动应用程序：\n``` json\ncd dist\nhttp-server -c-1 .\n```\n-c-1选项将禁用服务器缓存，服务器通常会在 port 上运行8080，为应用程序的生产版本提供服务。\n如果你有口8080被占用，应用程序可能运行在8081，8082等等，所使用的端口记录在启动时的控制台。\n如果您在另一台服务器上本地运行 REST API，例如在端口 9000 中，您还可以使用以下命令将任何 REST API 调用代理到它：\n``` json\nhttp-server -c-1 --proxy http://localhost:9000 . \n```\n在服务器运行后，让我们转到，看看我们使用 Chrome 开发工具运行了什么：http://localhost:8080\n\n![2](http://jsnext.icu/20211114134901.png)\n\n正如我们所看到的，我们现在已经运行了 V1 版本，并且我们已经安装了一个带有源文件的 Service Worker ngsw-worker.js\n\n#### 静态资源存储位置\n所有的 Javascript 和 CSS 文件，甚至包括所有的 Javascript 和 CSS 文件index.html都已在后台下载并安装在浏览器中以备后用\n\n这些文件都可以在缓存存储中找到，使用 Chrome 开发工具：\n![3](http://jsnext.icu/20211114135245.png)\nAngular Service Worker 将在您下次加载页面时开始提供应用程序文件。或者点击刷新，您可能会注意到应用程序启动得更快。\n\n#### 脱机访问\n为了确认应用程序确实被下载到用户浏览器中，让我们做一个测试：按下 Ctrl+C 来关闭服务器。\n\n现在让我们在关闭http-server进程后点击刷新：您可能会惊讶于应用程序仍在运行，我们得到了完全相同的屏幕！\n\n在控制台上，我们会发现以下消息：\n\n``` bash\nAn unknown error occurred when fetching the script.\nngsw-worker.js Failed to load resource: net::ERR_CONNECTION_REFUSED\n```\n\n唯一尝试从网络获取的文件是 Service Worker 文件本身，这是正常的。\n\n### 版本管理\n应用程序将静态文件都缓存到本存在一定的风险，当更新了代码发布了新版本的时候还是会从本地读取。\n\n假设我们对应用程序进行了一些小的更改，例如编辑styles.scss文件中的全局样式。在再次运行生产构建之前，让我们保留 之前的版本ngsw.json，以便我们可以看到发生了什么变化。\n\n现在让我们再次运行生产构建，并比较生成的ngsw.json文件：\n![4](http://jsnext.icu/20211114235245.png)\n\n正如我们所看到的，构建输出中唯一改变的是 CSS 包，所有剩余的文件都没有改变，除了index.html（加载新包的地方）\n\n#### Angular Service Worker 如何更新版本\n每次用户重新加载应用程序时，Angular Service Worker 都会检查ngsw.json服务器上是否有可用的新文件。\n\n这是为了与标准 Service Worker 行为保持一致，并避免应用程序的陈旧版本长时间运行。陈旧的版本可能包含错误甚至完全损坏，因此必须经常检查服务器上是否有新的应用程序版本可用。\n\n在我们的例子中，ngsw.json将比较文件的旧版本和新版本，并在后台下载并安装新的 CSS 包。\n\n下次用户重新加载页面时，将显示新的应用程序版本！\n\n#### 通知用户有新版本可用\n\n对于用户可能已打开数小时的长时间运行的 SPA 应用程序，我们可能希望定期检查服务器上是否有应用程序的新版本并将其安装在后台。\n\n为了检查新版本是否可用，我们可以使用该SwUpdate服务及其checkForUpdate()方法。\n\n但一般来说，checkForUpdate()手动调用不是必需的，因为 Angular Service Worker 会ngsw.json在每次完整的应用程序重新加载时寻找新版本，以与标准 Service Worker 生命周期保持一致。\n\n我们可以通过使用availableObservable来要求在新版本可用时得到通知SWUpdate，然后通过对话框询问用户是否想要获取新版本：\n\n```typescript\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent  implements OnInit {\n\n    constructor(private swUpdate: SwUpdate) {\n    }\n\n    ngOnInit() {\n\n        if (this.swUpdate.isEnabled) {\n\n            this.swUpdate.available.subscribe(() => {\n\n                if(confirm(\"New version available. Load New Version?\")) {\n\n                    window.location.reload();\n                }\n            });\n        }        \n    }\n}\n```\n当新的应用程序版本部署在服务器上时，让我们分解一下这段代码会发生什么：\n  - 新文件现在在服务器上可用，例如新的 CSS 或 Js \n  - ngsw.json服务器上有一个新文件，其中包含有关新应用程序版本的信息：加载哪些文件，何时加载等。\n\n这是正常的，因为用户仍然有一个 Service Worker 在浏览器中运行，它仍然为缓存存储中的所有文件提供服务，并且完全绕过网络。\n\n但是，Angular Service Worker 也会调用服务器以查看是否有新的ngsw.json，并ngsw.json在后台触发加载文件中提到的任何新文件。\n\n加载新应用程序版本的所有文件后，Angular Service Worker 将发出该available事件，这意味着新版本的应用程序可用。然后用户将看到以下内容：\n![5](http://jsnext.icu/20211120535245.png)\n\n如果用户单击`Ok`，则将重新加载完整的应用程序并显示新版本。请注意，如果我们没有向用户显示此对话框，则用户仍然会在下次重新加载时看到新版本。","source":"_posts/ng-pwa.md","raw":"---\ntitle: Angular Service Worker - PWA\n---\n[完整代码](https://github.com/Mr-Seventeen98/ngpwa)\n使用 Angular Service Worker 和 Angular CLI 内置的 PWA 支持，将 Web 应用程序转换成可下载和安装的移动应用程序。\n\n在此过程中，将了解 Angular Service Worker 的设计及其背后的工作原理，并了解它的工作方式与其他构建时生成 Service Worker 的不同。\n\n## 目录\n\n在这篇文章中，我们将讨论以下主题：\n\n- 使用 Angular CLI 搭建 Angular PWA 应用程序\n- 了解如何手动添加 Angular PWA 支持\n- 了解 Angular Service Worker 运行时缓存机制\n- 运行和理解 PWA 的构建\n- 在生产环境下启动 Angular PWA\n- 版本管理\n\n### 搭建 Angular PWA\n创建 Angular PWA 的第一步是将 Angular CLI 升级到最新版本：\n``` bash\nnpm install -g @angular/cli@latest\n```\n搭建一个 Angular 应用程序并添加 Angular Service Worker 相关pacakge\n``` bash\nng new angular-pwa-app\n```\n将 Angular Service Worker 添加到现有应用程序中\n`这里一定是用ng add 不能用npm i或者yarn add，因为ng add @angular/pwa 是angular cli 扩展的命令，会修改整个项目对PWA支持的文件，如果要使用 npm i 或者 yarn add的话，直接安装@angular/service-worker包，后面所有的文件改动都需要手动去修改`\n``` bash\nng add @angular/pwa\n```\n\n### 了解如何手动添加 Angular PWA 支持\n执行完第一步所有的操作后PWA的支持几乎已经被CLI处理完了。但我们需要知道它都改变了些什么，以防以后需要手动升级Angular应用或者是手动配置webpackage\n\n- @angular/service-worker包被添加到package.json. angular.json配置文件中多出了一项`\"serviceWorker\": true`\n``` json\n{\n  \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\",\n  \"cli\": {\n    \"analytics\": false\n  },\n  \"version\": 1,\n  \"newProjectRoot\": \"projects\",\n  \"projects\": {\n    \"angular-pwa-app\": {\n      \"projectType\": \"application\",\n      \"schematics\": {\n        ...\n      },\n      \"root\": \"\",\n      \"sourceRoot\": \"src\",\n      \"prefix\": \"app\",\n      \"architect\": {\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            \"outputPath\": \"dist/angular-pwa-app\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": \"src/polyfills.ts\",\n            \"tsConfig\": \"tsconfig.app.json\",\n            \"inlineStyleLanguage\": \"sass\",\n            \"assets\": [\n              ...\n            ],\n            \"styles\": [\n              \"src/styles.sass\"\n            ],\n            \"scripts\": [],\n            \"serviceWorker\": true, // 添加项\n            \"ngswConfigPath\": \"ngsw-config.json\"\n          },\n          \"configurations\": {\n            ...\n          },\n          \"defaultConfiguration\": \"production\"\n        },\n        \"serve\": {\n          ...\n        },\n        \"extract-i18n\": {\n          \"builder\": \"@angular-devkit/build-angular:extract-i18n\",\n          \"options\": {\n            \"browserTarget\": \"angular-pwa-app:build\"\n          }\n        },\n        \"test\": {\n          ...\n        }\n      }\n    }\n  },\n  \"defaultProject\": \"angular-pwa-app\"\n}\n```\n`serviceWorker` 节点有什么用途？\n将导致 `build` 后的 `dist` 文件夹中包含几个额外的文件：\n  - `ngsw-worker.js`: Angular Service Worker 文件\n  -  `ngsw.json`: Angular Service Worker 的运行时配置\n\n- 应用程序 `AppModule` 中添加了 `ServiceWorkerModule` 的注册\n```typescript\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    ServiceWorkerModule.register('ngsw-worker.js', {\n      enabled: environment.production,\n      // Register the ServiceWorker as soon as the app is stable\n      // or after 30 seconds (whichever comes first).\n      registrationStrategy: 'registerWhenStable:30000'\n    })\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n`ServiceWorkerModule` 有什么用途？\n这个模块提供了几个可注入的服务：\n  - `SwUpdate` 用于管理应用程序版本更新\n  - `SwPush` 用于执行服务器 Web 推送通知\n该模块通过调用 navigator.serviceWorker.register() 在用户浏览器中加载 ngsw-worker.js，在浏览器中注册 Angular Service Worker（浏览器支持Service Worker的情况下）。\n调用 register() 会导致 ngsw-worker.js 文件被加载到单独的 HTTP 请求中。有了这个，将我们的 Angular 应用程序转变为 PWA 只缺少一件事。\n\n- 构建配置文件 ngsw-config.json\nCLI 还添加了一个名为ngsw-config.json的配置文件，用于配置 Angular Service Worker 运行时参数，并且生成的文件带有一些默认值。\n```json\n{\n  \"$schema\": \"./node_modules/@angular/service-worker/config/schema.json\",\n  \"index\": \"/index.html\",\n  \"assetGroups\": [\n    {\n      \"name\": \"app\",\n      \"installMode\": \"prefetch\",\n      \"resources\": {\n        \"files\": [\n          \"/favicon.ico\",\n          \"/index.html\",\n          \"/manifest.webmanifest\",\n          \"/*.css\",\n          \"/*.js\"\n        ]\n      }\n    },\n    {\n      \"name\": \"assets\",\n      \"installMode\": \"lazy\",\n      \"updateMode\": \"prefetch\",\n      \"resources\": {\n        \"files\": [\n          \"/assets/**\",\n          \"/*.(svg|cur|jpg|jpeg|png|apng|webp|avif|gif|otf|ttf|woff|woff2)\"\n        ]\n      }\n    }\n  ]\n}\n```\n此文件包含默认缓存行为或 Angular Service Worker，它针对应用程序静态资产文件：index.html、CSS 和 Javascript。\n\n### Angular Service Worker 运行时缓存机制\nAngular Service Worker 可以在浏览器[CacheStorage](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage)中缓存各种内容\n\n这是一种基于Javascript的key/value缓存机制，与标准浏览器Cache-Control机制无关，两种机制可以分开使用。\n\nassetGroups配置文件部分的目标是准确配置 Angular Service Worker 在缓存存储中缓存的 HTTP 请求，并且有两个缓存配置条目：\n  - 一个名为 的条目app，用于所有单页应用程序文件（所有应用程序 index.html、CSS 和 Javascript 包以及图标）\n  - 另一个名为 的条目assets，用于也包含在 dist 文件夹中的任何其他资产，例如图像，但不一定是运行每个页面所必需的\n\n缓存静态文件是应用程序本身\n另一方面，资产文件仅在被请求时才被缓存（意味着是惰性的），但如果它们曾经被请求过一次，并且有新版本可用，那么它们将被提前下载（意味着这是预更新模式）。\n\n同样，对于在单独的 HTTP 请求中下载的任何资产（例如图像）来说，这是一个很好的策略，因为根据用户访问的页面，它们可能并不总是需要。\n\n但是如果他们需要一次，那么我们很可能也需要更新版本，所以我们不妨提前下载新版本。\n\n同样，这些是默认值，但我们可以调整它以适合我们自己的应用程序。但是，在应用程序文件的特定情况下，我们不太可能想使用其他策略。\n\n毕竟，应用缓存配置是我们正在寻找的下载和安装功能本身。也许我们使用 CLI 生成的包之外的其他文件？在这种情况下，我们希望调整我们的配置。\n\n重要的是要记住，有了这些默认设置，我们已经准备好了一个可下载和可安装的应用程序。\n\n### 运行和理解 PWA的构建\n首先向应用程序添加一些可视化内容，以清楚地标识在用户浏览器中运行的给定版本。例如，我们可以用以下内容替换app.component.html文件的内容：\n``` html\n<h1>Version V1 is runnning ...</h1>\n```\n现在让我们构建这个 PWA 应用程序。Angular Service Worker 仅在生产模式下可用，所以让我们首先对我们的应用程序进行生产构建：\n``` json\nng build --prod\n```\n\n#### 构建后的文件\n让我们看看我们的 build 文件夹中有什么，这里是生成的所有文件：\n![1](http://jsnext.icu/20211114085812.png)\n构建配置文件中的serviceWorker标志angular.json导致 Angular CLI 包含几个额外的文件\n\n#### ngsw-worker.js文件\n这个文件就是 Angular Service Worker 本身。与所有 Service Worker 一样，它通过自己单独的 HTTP 请求进行交付，以便浏览器可以跟踪它是否发生了变化，并将其应用于 Service Worker 生命周期\n\n它将ServiceWorkerModule通过调用间接触发此文件的加载navigation.serviceWorker.register()。\n\n然后，此文件将保持不变，直到您升级到包含新版本 Angular Service Worker 的新 Angular 版本。\n\n#### ngsw.json文件\n这是Angular Service Worker 将使用的运行时配置文件。该文件基于该文件构建ngsw-config.json，并包含 Angular Service Worker 在运行时了解它需要缓存哪些文件以及何时缓存所需的所有信息。\n```json\n{\n  \"configVersion\": 1,\n  \"timestamp\": 1636811800992,\n  \"index\": \"/index.html\",\n  \"assetGroups\": [\n    {\n      \"name\": \"app\",\n      \"installMode\": \"prefetch\",\n      \"updateMode\": \"prefetch\",\n      \"cacheQueryOptions\": {\n        \"ignoreVary\": true\n      },\n      \"urls\": [\n        \"/favicon.ico\",\n        \"/index.html\",\n        \"/main.9b1590cf6a3f05bd.js\",\n        \"/manifest.webmanifest\",\n        \"/polyfills.d2940b6b864d5b0c.js\",\n        \"/runtime.e6e2f4954d860551.js\",\n        \"/styles.ef46db3751d8e999.css\"\n      ],\n      \"patterns\": []\n    },\n    {\n      \"name\": \"assets\",\n      \"installMode\": \"lazy\",\n      \"updateMode\": \"prefetch\",\n      \"cacheQueryOptions\": {\n        \"ignoreVary\": true\n      },\n      \"urls\": [\n        \"/assets/icons/icon-128x128.png\",\n        \"/assets/icons/icon-144x144.png\",\n        \"/assets/icons/icon-152x152.png\",\n        \"/assets/icons/icon-192x192.png\",\n        \"/assets/icons/icon-384x384.png\",\n        \"/assets/icons/icon-512x512.png\",\n        \"/assets/icons/icon-72x72.png\",\n        \"/assets/icons/icon-96x96.png\"\n      ],\n      \"patterns\": []\n    }\n  ],\n  \"dataGroups\": [],\n  \"hashTable\": {\n    \"/assets/icons/icon-128x128.png\": \"dae3b6ed49bdaf4327b92531d4b5b4a5d30c7532\",\n    \"/assets/icons/icon-144x144.png\": \"b0bd89982e08f9bd2b642928f5391915b74799a7\",\n    \"/assets/icons/icon-152x152.png\": \"7479a9477815dfd9668d60f8b3b2fba709b91310\",\n    \"/assets/icons/icon-192x192.png\": \"1abd80d431a237a853ce38147d8c63752f10933b\",\n    \"/assets/icons/icon-384x384.png\": \"329749cd6393768d3131ed6304c136b1ca05f2fd\",\n    \"/assets/icons/icon-512x512.png\": \"559d9c4318b45a1f2b10596bbb4c960fe521dbcc\",\n    \"/assets/icons/icon-72x72.png\": \"c457e56089a36952cd67156f9996bc4ce54a5ed9\",\n    \"/assets/icons/icon-96x96.png\": \"3914125a4b445bf111c5627875fc190f560daa41\",\n    \"/favicon.ico\": \"22f6a4a3bcaafafb0254e0f2fa4ceb89e505e8b2\",\n    \"/index.html\": \"2dddde2e959d509b5875df1affbbdeeca0013ef5\",\n    \"/main.9b1590cf6a3f05bd.js\": \"a40c908f209a2e5ded532ecb14c6125fd64c6772\",\n    \"/manifest.webmanifest\": \"ccd3e1a5912adcc16f66473d4cba3e30f2bc0f04\",\n    \"/polyfills.d2940b6b864d5b0c.js\": \"48b7ab4dcc659f5bffded964098491e3504c8d66\",\n    \"/runtime.e6e2f4954d860551.js\": \"8e240156b422208604399acf6a5c744f5468a071\",\n    \"/styles.ef46db3751d8e999.css\": \"da39a3ee5e6b4b0d3255bfef95601890afd80709\"\n  },\n  \"navigationUrls\": [\n    {\n      \"positive\": true,\n      \"regex\": \"^\\\\/.*$\"\n    },\n    {\n      \"positive\": false,\n      \"regex\": \"^\\\\/(?:.+\\\\/)?[^/]*\\\\.[^/]*$\"\n    },\n    {\n      \"positive\": false,\n      \"regex\": \"^\\\\/(?:.+\\\\/)?[^/]*__[^/]*$\"\n    },\n    {\n      \"positive\": false,\n      \"regex\": \"^\\\\/(?:.+\\\\/)?[^/]*__[^/]*\\\\/.*$\"\n    }\n  ],\n  \"navigationRequestStrategy\": \"performance\"\n}\n```\n此文件是`ngsw-config.json`该文件的扩展版本，其中所有通配符 url 都已应用并替换为与之匹配的任何文件的路径。\n\n#### Angular Service Worker 如何使用ngsw.json\nAngular Service Worker 将在安装模式预取的情况下主动加载这些文件，或者在安装模式延迟的情况下根据需要加载这些文件，并且还将这些文件存储在缓存存储中\n\n此加载将在后台进行，因为用户首先加载应用程序。下次用户刷新页面时，Angular Service Worker 将拦截 HTTP 请求，并将提供缓存文件而不是从网络获取它们。\n\n每个资产在`hashTable`都有一个对应的哈希值。如果我们对此处列出的任何文件进行任何修改（即使它只有一个字符），我们将在以下 Angular CLI 构建中获得完全不同的哈希值。\n\n然后 Angular Service Worker 将知道该文件在服务器上有一个新版本，需要在适当的时间加载。\n\n### 生产环境下启动 Angular PWA\n然后让我们以生产模式启动应用程序，为此，我们需要一个小型 Web 服务器。一个不错的选择是http-server，让我们安装它：\n``` json\nnpm install -g http-server\n```\n然后让我们进入`dist/angular-pwa-app`文件夹，并以生产模式启动应用程序：\n``` json\ncd dist\nhttp-server -c-1 .\n```\n-c-1选项将禁用服务器缓存，服务器通常会在 port 上运行8080，为应用程序的生产版本提供服务。\n如果你有口8080被占用，应用程序可能运行在8081，8082等等，所使用的端口记录在启动时的控制台。\n如果您在另一台服务器上本地运行 REST API，例如在端口 9000 中，您还可以使用以下命令将任何 REST API 调用代理到它：\n``` json\nhttp-server -c-1 --proxy http://localhost:9000 . \n```\n在服务器运行后，让我们转到，看看我们使用 Chrome 开发工具运行了什么：http://localhost:8080\n\n![2](http://jsnext.icu/20211114134901.png)\n\n正如我们所看到的，我们现在已经运行了 V1 版本，并且我们已经安装了一个带有源文件的 Service Worker ngsw-worker.js\n\n#### 静态资源存储位置\n所有的 Javascript 和 CSS 文件，甚至包括所有的 Javascript 和 CSS 文件index.html都已在后台下载并安装在浏览器中以备后用\n\n这些文件都可以在缓存存储中找到，使用 Chrome 开发工具：\n![3](http://jsnext.icu/20211114135245.png)\nAngular Service Worker 将在您下次加载页面时开始提供应用程序文件。或者点击刷新，您可能会注意到应用程序启动得更快。\n\n#### 脱机访问\n为了确认应用程序确实被下载到用户浏览器中，让我们做一个测试：按下 Ctrl+C 来关闭服务器。\n\n现在让我们在关闭http-server进程后点击刷新：您可能会惊讶于应用程序仍在运行，我们得到了完全相同的屏幕！\n\n在控制台上，我们会发现以下消息：\n\n``` bash\nAn unknown error occurred when fetching the script.\nngsw-worker.js Failed to load resource: net::ERR_CONNECTION_REFUSED\n```\n\n唯一尝试从网络获取的文件是 Service Worker 文件本身，这是正常的。\n\n### 版本管理\n应用程序将静态文件都缓存到本存在一定的风险，当更新了代码发布了新版本的时候还是会从本地读取。\n\n假设我们对应用程序进行了一些小的更改，例如编辑styles.scss文件中的全局样式。在再次运行生产构建之前，让我们保留 之前的版本ngsw.json，以便我们可以看到发生了什么变化。\n\n现在让我们再次运行生产构建，并比较生成的ngsw.json文件：\n![4](http://jsnext.icu/20211114235245.png)\n\n正如我们所看到的，构建输出中唯一改变的是 CSS 包，所有剩余的文件都没有改变，除了index.html（加载新包的地方）\n\n#### Angular Service Worker 如何更新版本\n每次用户重新加载应用程序时，Angular Service Worker 都会检查ngsw.json服务器上是否有可用的新文件。\n\n这是为了与标准 Service Worker 行为保持一致，并避免应用程序的陈旧版本长时间运行。陈旧的版本可能包含错误甚至完全损坏，因此必须经常检查服务器上是否有新的应用程序版本可用。\n\n在我们的例子中，ngsw.json将比较文件的旧版本和新版本，并在后台下载并安装新的 CSS 包。\n\n下次用户重新加载页面时，将显示新的应用程序版本！\n\n#### 通知用户有新版本可用\n\n对于用户可能已打开数小时的长时间运行的 SPA 应用程序，我们可能希望定期检查服务器上是否有应用程序的新版本并将其安装在后台。\n\n为了检查新版本是否可用，我们可以使用该SwUpdate服务及其checkForUpdate()方法。\n\n但一般来说，checkForUpdate()手动调用不是必需的，因为 Angular Service Worker 会ngsw.json在每次完整的应用程序重新加载时寻找新版本，以与标准 Service Worker 生命周期保持一致。\n\n我们可以通过使用availableObservable来要求在新版本可用时得到通知SWUpdate，然后通过对话框询问用户是否想要获取新版本：\n\n```typescript\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent  implements OnInit {\n\n    constructor(private swUpdate: SwUpdate) {\n    }\n\n    ngOnInit() {\n\n        if (this.swUpdate.isEnabled) {\n\n            this.swUpdate.available.subscribe(() => {\n\n                if(confirm(\"New version available. Load New Version?\")) {\n\n                    window.location.reload();\n                }\n            });\n        }        \n    }\n}\n```\n当新的应用程序版本部署在服务器上时，让我们分解一下这段代码会发生什么：\n  - 新文件现在在服务器上可用，例如新的 CSS 或 Js \n  - ngsw.json服务器上有一个新文件，其中包含有关新应用程序版本的信息：加载哪些文件，何时加载等。\n\n这是正常的，因为用户仍然有一个 Service Worker 在浏览器中运行，它仍然为缓存存储中的所有文件提供服务，并且完全绕过网络。\n\n但是，Angular Service Worker 也会调用服务器以查看是否有新的ngsw.json，并ngsw.json在后台触发加载文件中提到的任何新文件。\n\n加载新应用程序版本的所有文件后，Angular Service Worker 将发出该available事件，这意味着新版本的应用程序可用。然后用户将看到以下内容：\n![5](http://jsnext.icu/20211120535245.png)\n\n如果用户单击`Ok`，则将重新加载完整的应用程序并显示新版本。请注意，如果我们没有向用户显示此对话框，则用户仍然会在下次重新加载时看到新版本。","slug":"ng-pwa","published":1,"date":"2021-11-22T15:36:33.685Z","updated":"2021-11-22T15:38:32.002Z","_id":"ckwau0wmr0000dwvj22jdbuuu","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://github.com/Mr-Seventeen98/ngpwa\">完整代码</a><br>使用 Angular Service Worker 和 Angular CLI 内置的 PWA 支持，将 Web 应用程序转换成可下载和安装的移动应用程序。</p>\n<p>在此过程中，将了解 Angular Service Worker 的设计及其背后的工作原理，并了解它的工作方式与其他构建时生成 Service Worker 的不同。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>在这篇文章中，我们将讨论以下主题：</p>\n<ul>\n<li>使用 Angular CLI 搭建 Angular PWA 应用程序</li>\n<li>了解如何手动添加 Angular PWA 支持</li>\n<li>了解 Angular Service Worker 运行时缓存机制</li>\n<li>运行和理解 PWA 的构建</li>\n<li>在生产环境下启动 Angular PWA</li>\n<li>版本管理</li>\n</ul>\n<h3 id=\"搭建-Angular-PWA\"><a href=\"#搭建-Angular-PWA\" class=\"headerlink\" title=\"搭建 Angular PWA\"></a>搭建 Angular PWA</h3><p>创建 Angular PWA 的第一步是将 Angular CLI 升级到最新版本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install -g @angular&#x2F;cli@latest</code></pre>\n<p>搭建一个 Angular 应用程序并添加 Angular Service Worker 相关pacakge</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ng new angular-pwa-app</code></pre>\n<p>将 Angular Service Worker 添加到现有应用程序中<br><code>这里一定是用ng add 不能用npm i或者yarn add，因为ng add @angular/pwa 是angular cli 扩展的命令，会修改整个项目对PWA支持的文件，如果要使用 npm i 或者 yarn add的话，直接安装@angular/service-worker包，后面所有的文件改动都需要手动去修改</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ng add @angular&#x2F;pwa</code></pre>\n\n<h3 id=\"了解如何手动添加-Angular-PWA-支持\"><a href=\"#了解如何手动添加-Angular-PWA-支持\" class=\"headerlink\" title=\"了解如何手动添加 Angular PWA 支持\"></a>了解如何手动添加 Angular PWA 支持</h3><p>执行完第一步所有的操作后PWA的支持几乎已经被CLI处理完了。但我们需要知道它都改变了些什么，以防以后需要手动升级Angular应用或者是手动配置webpackage</p>\n<ul>\n<li><p>@angular/service-worker包被添加到package.json. angular.json配置文件中多出了一项<code>&quot;serviceWorker&quot;: true</code></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;$schema&quot;: &quot;.&#x2F;node_modules&#x2F;@angular&#x2F;cli&#x2F;lib&#x2F;config&#x2F;schema.json&quot;,\n  &quot;cli&quot;: &#123;\n    &quot;analytics&quot;: false\n  &#125;,\n  &quot;version&quot;: 1,\n  &quot;newProjectRoot&quot;: &quot;projects&quot;,\n  &quot;projects&quot;: &#123;\n    &quot;angular-pwa-app&quot;: &#123;\n      &quot;projectType&quot;: &quot;application&quot;,\n      &quot;schematics&quot;: &#123;\n        ...\n      &#125;,\n      &quot;root&quot;: &quot;&quot;,\n      &quot;sourceRoot&quot;: &quot;src&quot;,\n      &quot;prefix&quot;: &quot;app&quot;,\n      &quot;architect&quot;: &#123;\n        &quot;build&quot;: &#123;\n          &quot;builder&quot;: &quot;@angular-devkit&#x2F;build-angular:browser&quot;,\n          &quot;options&quot;: &#123;\n            &quot;outputPath&quot;: &quot;dist&#x2F;angular-pwa-app&quot;,\n            &quot;index&quot;: &quot;src&#x2F;index.html&quot;,\n            &quot;main&quot;: &quot;src&#x2F;main.ts&quot;,\n            &quot;polyfills&quot;: &quot;src&#x2F;polyfills.ts&quot;,\n            &quot;tsConfig&quot;: &quot;tsconfig.app.json&quot;,\n            &quot;inlineStyleLanguage&quot;: &quot;sass&quot;,\n            &quot;assets&quot;: [\n              ...\n            ],\n            &quot;styles&quot;: [\n              &quot;src&#x2F;styles.sass&quot;\n            ],\n            &quot;scripts&quot;: [],\n            &quot;serviceWorker&quot;: true, &#x2F;&#x2F; 添加项\n            &quot;ngswConfigPath&quot;: &quot;ngsw-config.json&quot;\n          &#125;,\n          &quot;configurations&quot;: &#123;\n            ...\n          &#125;,\n          &quot;defaultConfiguration&quot;: &quot;production&quot;\n        &#125;,\n        &quot;serve&quot;: &#123;\n          ...\n        &#125;,\n        &quot;extract-i18n&quot;: &#123;\n          &quot;builder&quot;: &quot;@angular-devkit&#x2F;build-angular:extract-i18n&quot;,\n          &quot;options&quot;: &#123;\n            &quot;browserTarget&quot;: &quot;angular-pwa-app:build&quot;\n          &#125;\n        &#125;,\n        &quot;test&quot;: &#123;\n          ...\n        &#125;\n      &#125;\n    &#125;\n  &#125;,\n  &quot;defaultProject&quot;: &quot;angular-pwa-app&quot;\n&#125;</code></pre>\n<p><code>serviceWorker</code> 节点有什么用途？<br>将导致 <code>build</code> 后的 <code>dist</code> 文件夹中包含几个额外的文件：</p>\n<ul>\n<li><code>ngsw-worker.js</code>: Angular Service Worker 文件</li>\n<li> <code>ngsw.json</code>: Angular Service Worker 的运行时配置</li>\n</ul>\n</li>\n<li><p>应用程序 <code>AppModule</code> 中添加了 <code>ServiceWorkerModule</code> 的注册</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">@NgModule(&#123;\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    ServiceWorkerModule.register(&#39;ngsw-worker.js&#39;, &#123;\n      enabled: environment.production,\n      &#x2F;&#x2F; Register the ServiceWorker as soon as the app is stable\n      &#x2F;&#x2F; or after 30 seconds (whichever comes first).\n      registrationStrategy: &#39;registerWhenStable:30000&#39;\n    &#125;)\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n&#125;)\nexport class AppModule &#123; &#125;</code></pre>\n<p><code>ServiceWorkerModule</code> 有什么用途？<br>这个模块提供了几个可注入的服务：</p>\n<ul>\n<li><code>SwUpdate</code> 用于管理应用程序版本更新</li>\n<li><code>SwPush</code> 用于执行服务器 Web 推送通知<br>该模块通过调用 navigator.serviceWorker.register() 在用户浏览器中加载 ngsw-worker.js，在浏览器中注册 Angular Service Worker（浏览器支持Service Worker的情况下）。<br>调用 register() 会导致 ngsw-worker.js 文件被加载到单独的 HTTP 请求中。有了这个，将我们的 Angular 应用程序转变为 PWA 只缺少一件事。</li>\n</ul>\n</li>\n<li><p>构建配置文件 ngsw-config.json<br>CLI 还添加了一个名为ngsw-config.json的配置文件，用于配置 Angular Service Worker 运行时参数，并且生成的文件带有一些默认值。</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;$schema&quot;: &quot;.&#x2F;node_modules&#x2F;@angular&#x2F;service-worker&#x2F;config&#x2F;schema.json&quot;,\n  &quot;index&quot;: &quot;&#x2F;index.html&quot;,\n  &quot;assetGroups&quot;: [\n    &#123;\n      &quot;name&quot;: &quot;app&quot;,\n      &quot;installMode&quot;: &quot;prefetch&quot;,\n      &quot;resources&quot;: &#123;\n        &quot;files&quot;: [\n          &quot;&#x2F;favicon.ico&quot;,\n          &quot;&#x2F;index.html&quot;,\n          &quot;&#x2F;manifest.webmanifest&quot;,\n          &quot;&#x2F;*.css&quot;,\n          &quot;&#x2F;*.js&quot;\n        ]\n      &#125;\n    &#125;,\n    &#123;\n      &quot;name&quot;: &quot;assets&quot;,\n      &quot;installMode&quot;: &quot;lazy&quot;,\n      &quot;updateMode&quot;: &quot;prefetch&quot;,\n      &quot;resources&quot;: &#123;\n        &quot;files&quot;: [\n          &quot;&#x2F;assets&#x2F;**&quot;,\n          &quot;&#x2F;*.(svg|cur|jpg|jpeg|png|apng|webp|avif|gif|otf|ttf|woff|woff2)&quot;\n        ]\n      &#125;\n    &#125;\n  ]\n&#125;</code></pre>\n<p>此文件包含默认缓存行为或 Angular Service Worker，它针对应用程序静态资产文件：index.html、CSS 和 Javascript。</p>\n</li>\n</ul>\n<h3 id=\"Angular-Service-Worker-运行时缓存机制\"><a href=\"#Angular-Service-Worker-运行时缓存机制\" class=\"headerlink\" title=\"Angular Service Worker 运行时缓存机制\"></a>Angular Service Worker 运行时缓存机制</h3><p>Angular Service Worker 可以在浏览器<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage\">CacheStorage</a>中缓存各种内容</p>\n<p>这是一种基于Javascript的key/value缓存机制，与标准浏览器Cache-Control机制无关，两种机制可以分开使用。</p>\n<p>assetGroups配置文件部分的目标是准确配置 Angular Service Worker 在缓存存储中缓存的 HTTP 请求，并且有两个缓存配置条目：</p>\n<ul>\n<li>一个名为 的条目app，用于所有单页应用程序文件（所有应用程序 index.html、CSS 和 Javascript 包以及图标）</li>\n<li>另一个名为 的条目assets，用于也包含在 dist 文件夹中的任何其他资产，例如图像，但不一定是运行每个页面所必需的</li>\n</ul>\n<p>缓存静态文件是应用程序本身<br>另一方面，资产文件仅在被请求时才被缓存（意味着是惰性的），但如果它们曾经被请求过一次，并且有新版本可用，那么它们将被提前下载（意味着这是预更新模式）。</p>\n<p>同样，对于在单独的 HTTP 请求中下载的任何资产（例如图像）来说，这是一个很好的策略，因为根据用户访问的页面，它们可能并不总是需要。</p>\n<p>但是如果他们需要一次，那么我们很可能也需要更新版本，所以我们不妨提前下载新版本。</p>\n<p>同样，这些是默认值，但我们可以调整它以适合我们自己的应用程序。但是，在应用程序文件的特定情况下，我们不太可能想使用其他策略。</p>\n<p>毕竟，应用缓存配置是我们正在寻找的下载和安装功能本身。也许我们使用 CLI 生成的包之外的其他文件？在这种情况下，我们希望调整我们的配置。</p>\n<p>重要的是要记住，有了这些默认设置，我们已经准备好了一个可下载和可安装的应用程序。</p>\n<h3 id=\"运行和理解-PWA的构建\"><a href=\"#运行和理解-PWA的构建\" class=\"headerlink\" title=\"运行和理解 PWA的构建\"></a>运行和理解 PWA的构建</h3><p>首先向应用程序添加一些可视化内容，以清楚地标识在用户浏览器中运行的给定版本。例如，我们可以用以下内容替换app.component.html文件的内容：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;h1&gt;Version V1 is runnning ...&lt;&#x2F;h1&gt;</code></pre>\n<p>现在让我们构建这个 PWA 应用程序。Angular Service Worker 仅在生产模式下可用，所以让我们首先对我们的应用程序进行生产构建：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">ng build --prod</code></pre>\n\n<h4 id=\"构建后的文件\"><a href=\"#构建后的文件\" class=\"headerlink\" title=\"构建后的文件\"></a>构建后的文件</h4><p>让我们看看我们的 build 文件夹中有什么，这里是生成的所有文件：<br><img src=\"http://jsnext.icu/20211114085812.png\" alt=\"1\"><br>构建配置文件中的serviceWorker标志angular.json导致 Angular CLI 包含几个额外的文件</p>\n<h4 id=\"ngsw-worker-js文件\"><a href=\"#ngsw-worker-js文件\" class=\"headerlink\" title=\"ngsw-worker.js文件\"></a>ngsw-worker.js文件</h4><p>这个文件就是 Angular Service Worker 本身。与所有 Service Worker 一样，它通过自己单独的 HTTP 请求进行交付，以便浏览器可以跟踪它是否发生了变化，并将其应用于 Service Worker 生命周期</p>\n<p>它将ServiceWorkerModule通过调用间接触发此文件的加载navigation.serviceWorker.register()。</p>\n<p>然后，此文件将保持不变，直到您升级到包含新版本 Angular Service Worker 的新 Angular 版本。</p>\n<h4 id=\"ngsw-json文件\"><a href=\"#ngsw-json文件\" class=\"headerlink\" title=\"ngsw.json文件\"></a>ngsw.json文件</h4><p>这是Angular Service Worker 将使用的运行时配置文件。该文件基于该文件构建ngsw-config.json，并包含 Angular Service Worker 在运行时了解它需要缓存哪些文件以及何时缓存所需的所有信息。</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;configVersion&quot;: 1,\n  &quot;timestamp&quot;: 1636811800992,\n  &quot;index&quot;: &quot;&#x2F;index.html&quot;,\n  &quot;assetGroups&quot;: [\n    &#123;\n      &quot;name&quot;: &quot;app&quot;,\n      &quot;installMode&quot;: &quot;prefetch&quot;,\n      &quot;updateMode&quot;: &quot;prefetch&quot;,\n      &quot;cacheQueryOptions&quot;: &#123;\n        &quot;ignoreVary&quot;: true\n      &#125;,\n      &quot;urls&quot;: [\n        &quot;&#x2F;favicon.ico&quot;,\n        &quot;&#x2F;index.html&quot;,\n        &quot;&#x2F;main.9b1590cf6a3f05bd.js&quot;,\n        &quot;&#x2F;manifest.webmanifest&quot;,\n        &quot;&#x2F;polyfills.d2940b6b864d5b0c.js&quot;,\n        &quot;&#x2F;runtime.e6e2f4954d860551.js&quot;,\n        &quot;&#x2F;styles.ef46db3751d8e999.css&quot;\n      ],\n      &quot;patterns&quot;: []\n    &#125;,\n    &#123;\n      &quot;name&quot;: &quot;assets&quot;,\n      &quot;installMode&quot;: &quot;lazy&quot;,\n      &quot;updateMode&quot;: &quot;prefetch&quot;,\n      &quot;cacheQueryOptions&quot;: &#123;\n        &quot;ignoreVary&quot;: true\n      &#125;,\n      &quot;urls&quot;: [\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-128x128.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-144x144.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-152x152.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-192x192.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-384x384.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-512x512.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-72x72.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-96x96.png&quot;\n      ],\n      &quot;patterns&quot;: []\n    &#125;\n  ],\n  &quot;dataGroups&quot;: [],\n  &quot;hashTable&quot;: &#123;\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-128x128.png&quot;: &quot;dae3b6ed49bdaf4327b92531d4b5b4a5d30c7532&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-144x144.png&quot;: &quot;b0bd89982e08f9bd2b642928f5391915b74799a7&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-152x152.png&quot;: &quot;7479a9477815dfd9668d60f8b3b2fba709b91310&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-192x192.png&quot;: &quot;1abd80d431a237a853ce38147d8c63752f10933b&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-384x384.png&quot;: &quot;329749cd6393768d3131ed6304c136b1ca05f2fd&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-512x512.png&quot;: &quot;559d9c4318b45a1f2b10596bbb4c960fe521dbcc&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-72x72.png&quot;: &quot;c457e56089a36952cd67156f9996bc4ce54a5ed9&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-96x96.png&quot;: &quot;3914125a4b445bf111c5627875fc190f560daa41&quot;,\n    &quot;&#x2F;favicon.ico&quot;: &quot;22f6a4a3bcaafafb0254e0f2fa4ceb89e505e8b2&quot;,\n    &quot;&#x2F;index.html&quot;: &quot;2dddde2e959d509b5875df1affbbdeeca0013ef5&quot;,\n    &quot;&#x2F;main.9b1590cf6a3f05bd.js&quot;: &quot;a40c908f209a2e5ded532ecb14c6125fd64c6772&quot;,\n    &quot;&#x2F;manifest.webmanifest&quot;: &quot;ccd3e1a5912adcc16f66473d4cba3e30f2bc0f04&quot;,\n    &quot;&#x2F;polyfills.d2940b6b864d5b0c.js&quot;: &quot;48b7ab4dcc659f5bffded964098491e3504c8d66&quot;,\n    &quot;&#x2F;runtime.e6e2f4954d860551.js&quot;: &quot;8e240156b422208604399acf6a5c744f5468a071&quot;,\n    &quot;&#x2F;styles.ef46db3751d8e999.css&quot;: &quot;da39a3ee5e6b4b0d3255bfef95601890afd80709&quot;\n  &#125;,\n  &quot;navigationUrls&quot;: [\n    &#123;\n      &quot;positive&quot;: true,\n      &quot;regex&quot;: &quot;^\\\\&#x2F;.*$&quot;\n    &#125;,\n    &#123;\n      &quot;positive&quot;: false,\n      &quot;regex&quot;: &quot;^\\\\&#x2F;(?:.+\\\\&#x2F;)?[^&#x2F;]*\\\\.[^&#x2F;]*$&quot;\n    &#125;,\n    &#123;\n      &quot;positive&quot;: false,\n      &quot;regex&quot;: &quot;^\\\\&#x2F;(?:.+\\\\&#x2F;)?[^&#x2F;]*__[^&#x2F;]*$&quot;\n    &#125;,\n    &#123;\n      &quot;positive&quot;: false,\n      &quot;regex&quot;: &quot;^\\\\&#x2F;(?:.+\\\\&#x2F;)?[^&#x2F;]*__[^&#x2F;]*\\\\&#x2F;.*$&quot;\n    &#125;\n  ],\n  &quot;navigationRequestStrategy&quot;: &quot;performance&quot;\n&#125;</code></pre>\n<p>此文件是<code>ngsw-config.json</code>该文件的扩展版本，其中所有通配符 url 都已应用并替换为与之匹配的任何文件的路径。</p>\n<h4 id=\"Angular-Service-Worker-如何使用ngsw-json\"><a href=\"#Angular-Service-Worker-如何使用ngsw-json\" class=\"headerlink\" title=\"Angular Service Worker 如何使用ngsw.json\"></a>Angular Service Worker 如何使用ngsw.json</h4><p>Angular Service Worker 将在安装模式预取的情况下主动加载这些文件，或者在安装模式延迟的情况下根据需要加载这些文件，并且还将这些文件存储在缓存存储中</p>\n<p>此加载将在后台进行，因为用户首先加载应用程序。下次用户刷新页面时，Angular Service Worker 将拦截 HTTP 请求，并将提供缓存文件而不是从网络获取它们。</p>\n<p>每个资产在<code>hashTable</code>都有一个对应的哈希值。如果我们对此处列出的任何文件进行任何修改（即使它只有一个字符），我们将在以下 Angular CLI 构建中获得完全不同的哈希值。</p>\n<p>然后 Angular Service Worker 将知道该文件在服务器上有一个新版本，需要在适当的时间加载。</p>\n<h3 id=\"生产环境下启动-Angular-PWA\"><a href=\"#生产环境下启动-Angular-PWA\" class=\"headerlink\" title=\"生产环境下启动 Angular PWA\"></a>生产环境下启动 Angular PWA</h3><p>然后让我们以生产模式启动应用程序，为此，我们需要一个小型 Web 服务器。一个不错的选择是http-server，让我们安装它：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">npm install -g http-server</code></pre>\n<p>然后让我们进入<code>dist/angular-pwa-app</code>文件夹，并以生产模式启动应用程序：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">cd dist\nhttp-server -c-1 .</code></pre>\n<p>-c-1选项将禁用服务器缓存，服务器通常会在 port 上运行8080，为应用程序的生产版本提供服务。<br>如果你有口8080被占用，应用程序可能运行在8081，8082等等，所使用的端口记录在启动时的控制台。<br>如果您在另一台服务器上本地运行 REST API，例如在端口 9000 中，您还可以使用以下命令将任何 REST API 调用代理到它：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">http-server -c-1 --proxy http:&#x2F;&#x2F;localhost:9000 . </code></pre>\n<p>在服务器运行后，让我们转到，看看我们使用 Chrome 开发工具运行了什么：<a href=\"http://localhost:8080/\">http://localhost:8080</a></p>\n<p><img src=\"http://jsnext.icu/20211114134901.png\" alt=\"2\"></p>\n<p>正如我们所看到的，我们现在已经运行了 V1 版本，并且我们已经安装了一个带有源文件的 Service Worker ngsw-worker.js</p>\n<h4 id=\"静态资源存储位置\"><a href=\"#静态资源存储位置\" class=\"headerlink\" title=\"静态资源存储位置\"></a>静态资源存储位置</h4><p>所有的 Javascript 和 CSS 文件，甚至包括所有的 Javascript 和 CSS 文件index.html都已在后台下载并安装在浏览器中以备后用</p>\n<p>这些文件都可以在缓存存储中找到，使用 Chrome 开发工具：<br><img src=\"http://jsnext.icu/20211114135245.png\" alt=\"3\"><br>Angular Service Worker 将在您下次加载页面时开始提供应用程序文件。或者点击刷新，您可能会注意到应用程序启动得更快。</p>\n<h4 id=\"脱机访问\"><a href=\"#脱机访问\" class=\"headerlink\" title=\"脱机访问\"></a>脱机访问</h4><p>为了确认应用程序确实被下载到用户浏览器中，让我们做一个测试：按下 Ctrl+C 来关闭服务器。</p>\n<p>现在让我们在关闭http-server进程后点击刷新：您可能会惊讶于应用程序仍在运行，我们得到了完全相同的屏幕！</p>\n<p>在控制台上，我们会发现以下消息：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">An unknown error occurred when fetching the script.\nngsw-worker.js Failed to load resource: net::ERR_CONNECTION_REFUSED</code></pre>\n\n<p>唯一尝试从网络获取的文件是 Service Worker 文件本身，这是正常的。</p>\n<h3 id=\"版本管理\"><a href=\"#版本管理\" class=\"headerlink\" title=\"版本管理\"></a>版本管理</h3><p>应用程序将静态文件都缓存到本存在一定的风险，当更新了代码发布了新版本的时候还是会从本地读取。</p>\n<p>假设我们对应用程序进行了一些小的更改，例如编辑styles.scss文件中的全局样式。在再次运行生产构建之前，让我们保留 之前的版本ngsw.json，以便我们可以看到发生了什么变化。</p>\n<p>现在让我们再次运行生产构建，并比较生成的ngsw.json文件：<br><img src=\"http://jsnext.icu/20211114235245.png\" alt=\"4\"></p>\n<p>正如我们所看到的，构建输出中唯一改变的是 CSS 包，所有剩余的文件都没有改变，除了index.html（加载新包的地方）</p>\n<h4 id=\"Angular-Service-Worker-如何更新版本\"><a href=\"#Angular-Service-Worker-如何更新版本\" class=\"headerlink\" title=\"Angular Service Worker 如何更新版本\"></a>Angular Service Worker 如何更新版本</h4><p>每次用户重新加载应用程序时，Angular Service Worker 都会检查ngsw.json服务器上是否有可用的新文件。</p>\n<p>这是为了与标准 Service Worker 行为保持一致，并避免应用程序的陈旧版本长时间运行。陈旧的版本可能包含错误甚至完全损坏，因此必须经常检查服务器上是否有新的应用程序版本可用。</p>\n<p>在我们的例子中，ngsw.json将比较文件的旧版本和新版本，并在后台下载并安装新的 CSS 包。</p>\n<p>下次用户重新加载页面时，将显示新的应用程序版本！</p>\n<h4 id=\"通知用户有新版本可用\"><a href=\"#通知用户有新版本可用\" class=\"headerlink\" title=\"通知用户有新版本可用\"></a>通知用户有新版本可用</h4><p>对于用户可能已打开数小时的长时间运行的 SPA 应用程序，我们可能希望定期检查服务器上是否有应用程序的新版本并将其安装在后台。</p>\n<p>为了检查新版本是否可用，我们可以使用该SwUpdate服务及其checkForUpdate()方法。</p>\n<p>但一般来说，checkForUpdate()手动调用不是必需的，因为 Angular Service Worker 会ngsw.json在每次完整的应用程序重新加载时寻找新版本，以与标准 Service Worker 生命周期保持一致。</p>\n<p>我们可以通过使用availableObservable来要求在新版本可用时得到通知SWUpdate，然后通过对话框询问用户是否想要获取新版本：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">@Component(&#123;\n  selector: &#39;app-root&#39;,\n  templateUrl: &#39;.&#x2F;app.component.html&#39;,\n  styleUrls: [&#39;.&#x2F;app.component.css&#39;]\n&#125;)\nexport class AppComponent  implements OnInit &#123;\n\n    constructor(private swUpdate: SwUpdate) &#123;\n    &#125;\n\n    ngOnInit() &#123;\n\n        if (this.swUpdate.isEnabled) &#123;\n\n            this.swUpdate.available.subscribe(() &#x3D;&gt; &#123;\n\n                if(confirm(&quot;New version available. Load New Version?&quot;)) &#123;\n\n                    window.location.reload();\n                &#125;\n            &#125;);\n        &#125;        \n    &#125;\n&#125;</code></pre>\n<p>当新的应用程序版本部署在服务器上时，让我们分解一下这段代码会发生什么：</p>\n<ul>\n<li>新文件现在在服务器上可用，例如新的 CSS 或 Js </li>\n<li>ngsw.json服务器上有一个新文件，其中包含有关新应用程序版本的信息：加载哪些文件，何时加载等。</li>\n</ul>\n<p>这是正常的，因为用户仍然有一个 Service Worker 在浏览器中运行，它仍然为缓存存储中的所有文件提供服务，并且完全绕过网络。</p>\n<p>但是，Angular Service Worker 也会调用服务器以查看是否有新的ngsw.json，并ngsw.json在后台触发加载文件中提到的任何新文件。</p>\n<p>加载新应用程序版本的所有文件后，Angular Service Worker 将发出该available事件，这意味着新版本的应用程序可用。然后用户将看到以下内容：<br><img src=\"http://jsnext.icu/20211120535245.png\" alt=\"5\"></p>\n<p>如果用户单击<code>Ok</code>，则将重新加载完整的应用程序并显示新版本。请注意，如果我们没有向用户显示此对话框，则用户仍然会在下次重新加载时看到新版本。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/Mr-Seventeen98/ngpwa\">完整代码</a><br>使用 Angular Service Worker 和 Angular CLI 内置的 PWA 支持，将 Web 应用程序转换成可下载和安装的移动应用程序。</p>\n<p>在此过程中，将了解 Angular Service Worker 的设计及其背后的工作原理，并了解它的工作方式与其他构建时生成 Service Worker 的不同。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>在这篇文章中，我们将讨论以下主题：</p>\n<ul>\n<li>使用 Angular CLI 搭建 Angular PWA 应用程序</li>\n<li>了解如何手动添加 Angular PWA 支持</li>\n<li>了解 Angular Service Worker 运行时缓存机制</li>\n<li>运行和理解 PWA 的构建</li>\n<li>在生产环境下启动 Angular PWA</li>\n<li>版本管理</li>\n</ul>\n<h3 id=\"搭建-Angular-PWA\"><a href=\"#搭建-Angular-PWA\" class=\"headerlink\" title=\"搭建 Angular PWA\"></a>搭建 Angular PWA</h3><p>创建 Angular PWA 的第一步是将 Angular CLI 升级到最新版本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install -g @angular&#x2F;cli@latest</code></pre>\n<p>搭建一个 Angular 应用程序并添加 Angular Service Worker 相关pacakge</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ng new angular-pwa-app</code></pre>\n<p>将 Angular Service Worker 添加到现有应用程序中<br><code>这里一定是用ng add 不能用npm i或者yarn add，因为ng add @angular/pwa 是angular cli 扩展的命令，会修改整个项目对PWA支持的文件，如果要使用 npm i 或者 yarn add的话，直接安装@angular/service-worker包，后面所有的文件改动都需要手动去修改</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ng add @angular&#x2F;pwa</code></pre>\n\n<h3 id=\"了解如何手动添加-Angular-PWA-支持\"><a href=\"#了解如何手动添加-Angular-PWA-支持\" class=\"headerlink\" title=\"了解如何手动添加 Angular PWA 支持\"></a>了解如何手动添加 Angular PWA 支持</h3><p>执行完第一步所有的操作后PWA的支持几乎已经被CLI处理完了。但我们需要知道它都改变了些什么，以防以后需要手动升级Angular应用或者是手动配置webpackage</p>\n<ul>\n<li><p>@angular/service-worker包被添加到package.json. angular.json配置文件中多出了一项<code>&quot;serviceWorker&quot;: true</code></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;$schema&quot;: &quot;.&#x2F;node_modules&#x2F;@angular&#x2F;cli&#x2F;lib&#x2F;config&#x2F;schema.json&quot;,\n  &quot;cli&quot;: &#123;\n    &quot;analytics&quot;: false\n  &#125;,\n  &quot;version&quot;: 1,\n  &quot;newProjectRoot&quot;: &quot;projects&quot;,\n  &quot;projects&quot;: &#123;\n    &quot;angular-pwa-app&quot;: &#123;\n      &quot;projectType&quot;: &quot;application&quot;,\n      &quot;schematics&quot;: &#123;\n        ...\n      &#125;,\n      &quot;root&quot;: &quot;&quot;,\n      &quot;sourceRoot&quot;: &quot;src&quot;,\n      &quot;prefix&quot;: &quot;app&quot;,\n      &quot;architect&quot;: &#123;\n        &quot;build&quot;: &#123;\n          &quot;builder&quot;: &quot;@angular-devkit&#x2F;build-angular:browser&quot;,\n          &quot;options&quot;: &#123;\n            &quot;outputPath&quot;: &quot;dist&#x2F;angular-pwa-app&quot;,\n            &quot;index&quot;: &quot;src&#x2F;index.html&quot;,\n            &quot;main&quot;: &quot;src&#x2F;main.ts&quot;,\n            &quot;polyfills&quot;: &quot;src&#x2F;polyfills.ts&quot;,\n            &quot;tsConfig&quot;: &quot;tsconfig.app.json&quot;,\n            &quot;inlineStyleLanguage&quot;: &quot;sass&quot;,\n            &quot;assets&quot;: [\n              ...\n            ],\n            &quot;styles&quot;: [\n              &quot;src&#x2F;styles.sass&quot;\n            ],\n            &quot;scripts&quot;: [],\n            &quot;serviceWorker&quot;: true, &#x2F;&#x2F; 添加项\n            &quot;ngswConfigPath&quot;: &quot;ngsw-config.json&quot;\n          &#125;,\n          &quot;configurations&quot;: &#123;\n            ...\n          &#125;,\n          &quot;defaultConfiguration&quot;: &quot;production&quot;\n        &#125;,\n        &quot;serve&quot;: &#123;\n          ...\n        &#125;,\n        &quot;extract-i18n&quot;: &#123;\n          &quot;builder&quot;: &quot;@angular-devkit&#x2F;build-angular:extract-i18n&quot;,\n          &quot;options&quot;: &#123;\n            &quot;browserTarget&quot;: &quot;angular-pwa-app:build&quot;\n          &#125;\n        &#125;,\n        &quot;test&quot;: &#123;\n          ...\n        &#125;\n      &#125;\n    &#125;\n  &#125;,\n  &quot;defaultProject&quot;: &quot;angular-pwa-app&quot;\n&#125;</code></pre>\n<p><code>serviceWorker</code> 节点有什么用途？<br>将导致 <code>build</code> 后的 <code>dist</code> 文件夹中包含几个额外的文件：</p>\n<ul>\n<li><code>ngsw-worker.js</code>: Angular Service Worker 文件</li>\n<li> <code>ngsw.json</code>: Angular Service Worker 的运行时配置</li>\n</ul>\n</li>\n<li><p>应用程序 <code>AppModule</code> 中添加了 <code>ServiceWorkerModule</code> 的注册</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">@NgModule(&#123;\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    ServiceWorkerModule.register(&#39;ngsw-worker.js&#39;, &#123;\n      enabled: environment.production,\n      &#x2F;&#x2F; Register the ServiceWorker as soon as the app is stable\n      &#x2F;&#x2F; or after 30 seconds (whichever comes first).\n      registrationStrategy: &#39;registerWhenStable:30000&#39;\n    &#125;)\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n&#125;)\nexport class AppModule &#123; &#125;</code></pre>\n<p><code>ServiceWorkerModule</code> 有什么用途？<br>这个模块提供了几个可注入的服务：</p>\n<ul>\n<li><code>SwUpdate</code> 用于管理应用程序版本更新</li>\n<li><code>SwPush</code> 用于执行服务器 Web 推送通知<br>该模块通过调用 navigator.serviceWorker.register() 在用户浏览器中加载 ngsw-worker.js，在浏览器中注册 Angular Service Worker（浏览器支持Service Worker的情况下）。<br>调用 register() 会导致 ngsw-worker.js 文件被加载到单独的 HTTP 请求中。有了这个，将我们的 Angular 应用程序转变为 PWA 只缺少一件事。</li>\n</ul>\n</li>\n<li><p>构建配置文件 ngsw-config.json<br>CLI 还添加了一个名为ngsw-config.json的配置文件，用于配置 Angular Service Worker 运行时参数，并且生成的文件带有一些默认值。</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;$schema&quot;: &quot;.&#x2F;node_modules&#x2F;@angular&#x2F;service-worker&#x2F;config&#x2F;schema.json&quot;,\n  &quot;index&quot;: &quot;&#x2F;index.html&quot;,\n  &quot;assetGroups&quot;: [\n    &#123;\n      &quot;name&quot;: &quot;app&quot;,\n      &quot;installMode&quot;: &quot;prefetch&quot;,\n      &quot;resources&quot;: &#123;\n        &quot;files&quot;: [\n          &quot;&#x2F;favicon.ico&quot;,\n          &quot;&#x2F;index.html&quot;,\n          &quot;&#x2F;manifest.webmanifest&quot;,\n          &quot;&#x2F;*.css&quot;,\n          &quot;&#x2F;*.js&quot;\n        ]\n      &#125;\n    &#125;,\n    &#123;\n      &quot;name&quot;: &quot;assets&quot;,\n      &quot;installMode&quot;: &quot;lazy&quot;,\n      &quot;updateMode&quot;: &quot;prefetch&quot;,\n      &quot;resources&quot;: &#123;\n        &quot;files&quot;: [\n          &quot;&#x2F;assets&#x2F;**&quot;,\n          &quot;&#x2F;*.(svg|cur|jpg|jpeg|png|apng|webp|avif|gif|otf|ttf|woff|woff2)&quot;\n        ]\n      &#125;\n    &#125;\n  ]\n&#125;</code></pre>\n<p>此文件包含默认缓存行为或 Angular Service Worker，它针对应用程序静态资产文件：index.html、CSS 和 Javascript。</p>\n</li>\n</ul>\n<h3 id=\"Angular-Service-Worker-运行时缓存机制\"><a href=\"#Angular-Service-Worker-运行时缓存机制\" class=\"headerlink\" title=\"Angular Service Worker 运行时缓存机制\"></a>Angular Service Worker 运行时缓存机制</h3><p>Angular Service Worker 可以在浏览器<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage\">CacheStorage</a>中缓存各种内容</p>\n<p>这是一种基于Javascript的key/value缓存机制，与标准浏览器Cache-Control机制无关，两种机制可以分开使用。</p>\n<p>assetGroups配置文件部分的目标是准确配置 Angular Service Worker 在缓存存储中缓存的 HTTP 请求，并且有两个缓存配置条目：</p>\n<ul>\n<li>一个名为 的条目app，用于所有单页应用程序文件（所有应用程序 index.html、CSS 和 Javascript 包以及图标）</li>\n<li>另一个名为 的条目assets，用于也包含在 dist 文件夹中的任何其他资产，例如图像，但不一定是运行每个页面所必需的</li>\n</ul>\n<p>缓存静态文件是应用程序本身<br>另一方面，资产文件仅在被请求时才被缓存（意味着是惰性的），但如果它们曾经被请求过一次，并且有新版本可用，那么它们将被提前下载（意味着这是预更新模式）。</p>\n<p>同样，对于在单独的 HTTP 请求中下载的任何资产（例如图像）来说，这是一个很好的策略，因为根据用户访问的页面，它们可能并不总是需要。</p>\n<p>但是如果他们需要一次，那么我们很可能也需要更新版本，所以我们不妨提前下载新版本。</p>\n<p>同样，这些是默认值，但我们可以调整它以适合我们自己的应用程序。但是，在应用程序文件的特定情况下，我们不太可能想使用其他策略。</p>\n<p>毕竟，应用缓存配置是我们正在寻找的下载和安装功能本身。也许我们使用 CLI 生成的包之外的其他文件？在这种情况下，我们希望调整我们的配置。</p>\n<p>重要的是要记住，有了这些默认设置，我们已经准备好了一个可下载和可安装的应用程序。</p>\n<h3 id=\"运行和理解-PWA的构建\"><a href=\"#运行和理解-PWA的构建\" class=\"headerlink\" title=\"运行和理解 PWA的构建\"></a>运行和理解 PWA的构建</h3><p>首先向应用程序添加一些可视化内容，以清楚地标识在用户浏览器中运行的给定版本。例如，我们可以用以下内容替换app.component.html文件的内容：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;h1&gt;Version V1 is runnning ...&lt;&#x2F;h1&gt;</code></pre>\n<p>现在让我们构建这个 PWA 应用程序。Angular Service Worker 仅在生产模式下可用，所以让我们首先对我们的应用程序进行生产构建：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">ng build --prod</code></pre>\n\n<h4 id=\"构建后的文件\"><a href=\"#构建后的文件\" class=\"headerlink\" title=\"构建后的文件\"></a>构建后的文件</h4><p>让我们看看我们的 build 文件夹中有什么，这里是生成的所有文件：<br><img src=\"http://jsnext.icu/20211114085812.png\" alt=\"1\"><br>构建配置文件中的serviceWorker标志angular.json导致 Angular CLI 包含几个额外的文件</p>\n<h4 id=\"ngsw-worker-js文件\"><a href=\"#ngsw-worker-js文件\" class=\"headerlink\" title=\"ngsw-worker.js文件\"></a>ngsw-worker.js文件</h4><p>这个文件就是 Angular Service Worker 本身。与所有 Service Worker 一样，它通过自己单独的 HTTP 请求进行交付，以便浏览器可以跟踪它是否发生了变化，并将其应用于 Service Worker 生命周期</p>\n<p>它将ServiceWorkerModule通过调用间接触发此文件的加载navigation.serviceWorker.register()。</p>\n<p>然后，此文件将保持不变，直到您升级到包含新版本 Angular Service Worker 的新 Angular 版本。</p>\n<h4 id=\"ngsw-json文件\"><a href=\"#ngsw-json文件\" class=\"headerlink\" title=\"ngsw.json文件\"></a>ngsw.json文件</h4><p>这是Angular Service Worker 将使用的运行时配置文件。该文件基于该文件构建ngsw-config.json，并包含 Angular Service Worker 在运行时了解它需要缓存哪些文件以及何时缓存所需的所有信息。</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;configVersion&quot;: 1,\n  &quot;timestamp&quot;: 1636811800992,\n  &quot;index&quot;: &quot;&#x2F;index.html&quot;,\n  &quot;assetGroups&quot;: [\n    &#123;\n      &quot;name&quot;: &quot;app&quot;,\n      &quot;installMode&quot;: &quot;prefetch&quot;,\n      &quot;updateMode&quot;: &quot;prefetch&quot;,\n      &quot;cacheQueryOptions&quot;: &#123;\n        &quot;ignoreVary&quot;: true\n      &#125;,\n      &quot;urls&quot;: [\n        &quot;&#x2F;favicon.ico&quot;,\n        &quot;&#x2F;index.html&quot;,\n        &quot;&#x2F;main.9b1590cf6a3f05bd.js&quot;,\n        &quot;&#x2F;manifest.webmanifest&quot;,\n        &quot;&#x2F;polyfills.d2940b6b864d5b0c.js&quot;,\n        &quot;&#x2F;runtime.e6e2f4954d860551.js&quot;,\n        &quot;&#x2F;styles.ef46db3751d8e999.css&quot;\n      ],\n      &quot;patterns&quot;: []\n    &#125;,\n    &#123;\n      &quot;name&quot;: &quot;assets&quot;,\n      &quot;installMode&quot;: &quot;lazy&quot;,\n      &quot;updateMode&quot;: &quot;prefetch&quot;,\n      &quot;cacheQueryOptions&quot;: &#123;\n        &quot;ignoreVary&quot;: true\n      &#125;,\n      &quot;urls&quot;: [\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-128x128.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-144x144.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-152x152.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-192x192.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-384x384.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-512x512.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-72x72.png&quot;,\n        &quot;&#x2F;assets&#x2F;icons&#x2F;icon-96x96.png&quot;\n      ],\n      &quot;patterns&quot;: []\n    &#125;\n  ],\n  &quot;dataGroups&quot;: [],\n  &quot;hashTable&quot;: &#123;\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-128x128.png&quot;: &quot;dae3b6ed49bdaf4327b92531d4b5b4a5d30c7532&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-144x144.png&quot;: &quot;b0bd89982e08f9bd2b642928f5391915b74799a7&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-152x152.png&quot;: &quot;7479a9477815dfd9668d60f8b3b2fba709b91310&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-192x192.png&quot;: &quot;1abd80d431a237a853ce38147d8c63752f10933b&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-384x384.png&quot;: &quot;329749cd6393768d3131ed6304c136b1ca05f2fd&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-512x512.png&quot;: &quot;559d9c4318b45a1f2b10596bbb4c960fe521dbcc&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-72x72.png&quot;: &quot;c457e56089a36952cd67156f9996bc4ce54a5ed9&quot;,\n    &quot;&#x2F;assets&#x2F;icons&#x2F;icon-96x96.png&quot;: &quot;3914125a4b445bf111c5627875fc190f560daa41&quot;,\n    &quot;&#x2F;favicon.ico&quot;: &quot;22f6a4a3bcaafafb0254e0f2fa4ceb89e505e8b2&quot;,\n    &quot;&#x2F;index.html&quot;: &quot;2dddde2e959d509b5875df1affbbdeeca0013ef5&quot;,\n    &quot;&#x2F;main.9b1590cf6a3f05bd.js&quot;: &quot;a40c908f209a2e5ded532ecb14c6125fd64c6772&quot;,\n    &quot;&#x2F;manifest.webmanifest&quot;: &quot;ccd3e1a5912adcc16f66473d4cba3e30f2bc0f04&quot;,\n    &quot;&#x2F;polyfills.d2940b6b864d5b0c.js&quot;: &quot;48b7ab4dcc659f5bffded964098491e3504c8d66&quot;,\n    &quot;&#x2F;runtime.e6e2f4954d860551.js&quot;: &quot;8e240156b422208604399acf6a5c744f5468a071&quot;,\n    &quot;&#x2F;styles.ef46db3751d8e999.css&quot;: &quot;da39a3ee5e6b4b0d3255bfef95601890afd80709&quot;\n  &#125;,\n  &quot;navigationUrls&quot;: [\n    &#123;\n      &quot;positive&quot;: true,\n      &quot;regex&quot;: &quot;^\\\\&#x2F;.*$&quot;\n    &#125;,\n    &#123;\n      &quot;positive&quot;: false,\n      &quot;regex&quot;: &quot;^\\\\&#x2F;(?:.+\\\\&#x2F;)?[^&#x2F;]*\\\\.[^&#x2F;]*$&quot;\n    &#125;,\n    &#123;\n      &quot;positive&quot;: false,\n      &quot;regex&quot;: &quot;^\\\\&#x2F;(?:.+\\\\&#x2F;)?[^&#x2F;]*__[^&#x2F;]*$&quot;\n    &#125;,\n    &#123;\n      &quot;positive&quot;: false,\n      &quot;regex&quot;: &quot;^\\\\&#x2F;(?:.+\\\\&#x2F;)?[^&#x2F;]*__[^&#x2F;]*\\\\&#x2F;.*$&quot;\n    &#125;\n  ],\n  &quot;navigationRequestStrategy&quot;: &quot;performance&quot;\n&#125;</code></pre>\n<p>此文件是<code>ngsw-config.json</code>该文件的扩展版本，其中所有通配符 url 都已应用并替换为与之匹配的任何文件的路径。</p>\n<h4 id=\"Angular-Service-Worker-如何使用ngsw-json\"><a href=\"#Angular-Service-Worker-如何使用ngsw-json\" class=\"headerlink\" title=\"Angular Service Worker 如何使用ngsw.json\"></a>Angular Service Worker 如何使用ngsw.json</h4><p>Angular Service Worker 将在安装模式预取的情况下主动加载这些文件，或者在安装模式延迟的情况下根据需要加载这些文件，并且还将这些文件存储在缓存存储中</p>\n<p>此加载将在后台进行，因为用户首先加载应用程序。下次用户刷新页面时，Angular Service Worker 将拦截 HTTP 请求，并将提供缓存文件而不是从网络获取它们。</p>\n<p>每个资产在<code>hashTable</code>都有一个对应的哈希值。如果我们对此处列出的任何文件进行任何修改（即使它只有一个字符），我们将在以下 Angular CLI 构建中获得完全不同的哈希值。</p>\n<p>然后 Angular Service Worker 将知道该文件在服务器上有一个新版本，需要在适当的时间加载。</p>\n<h3 id=\"生产环境下启动-Angular-PWA\"><a href=\"#生产环境下启动-Angular-PWA\" class=\"headerlink\" title=\"生产环境下启动 Angular PWA\"></a>生产环境下启动 Angular PWA</h3><p>然后让我们以生产模式启动应用程序，为此，我们需要一个小型 Web 服务器。一个不错的选择是http-server，让我们安装它：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">npm install -g http-server</code></pre>\n<p>然后让我们进入<code>dist/angular-pwa-app</code>文件夹，并以生产模式启动应用程序：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">cd dist\nhttp-server -c-1 .</code></pre>\n<p>-c-1选项将禁用服务器缓存，服务器通常会在 port 上运行8080，为应用程序的生产版本提供服务。<br>如果你有口8080被占用，应用程序可能运行在8081，8082等等，所使用的端口记录在启动时的控制台。<br>如果您在另一台服务器上本地运行 REST API，例如在端口 9000 中，您还可以使用以下命令将任何 REST API 调用代理到它：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">http-server -c-1 --proxy http:&#x2F;&#x2F;localhost:9000 . </code></pre>\n<p>在服务器运行后，让我们转到，看看我们使用 Chrome 开发工具运行了什么：<a href=\"http://localhost:8080/\">http://localhost:8080</a></p>\n<p><img src=\"http://jsnext.icu/20211114134901.png\" alt=\"2\"></p>\n<p>正如我们所看到的，我们现在已经运行了 V1 版本，并且我们已经安装了一个带有源文件的 Service Worker ngsw-worker.js</p>\n<h4 id=\"静态资源存储位置\"><a href=\"#静态资源存储位置\" class=\"headerlink\" title=\"静态资源存储位置\"></a>静态资源存储位置</h4><p>所有的 Javascript 和 CSS 文件，甚至包括所有的 Javascript 和 CSS 文件index.html都已在后台下载并安装在浏览器中以备后用</p>\n<p>这些文件都可以在缓存存储中找到，使用 Chrome 开发工具：<br><img src=\"http://jsnext.icu/20211114135245.png\" alt=\"3\"><br>Angular Service Worker 将在您下次加载页面时开始提供应用程序文件。或者点击刷新，您可能会注意到应用程序启动得更快。</p>\n<h4 id=\"脱机访问\"><a href=\"#脱机访问\" class=\"headerlink\" title=\"脱机访问\"></a>脱机访问</h4><p>为了确认应用程序确实被下载到用户浏览器中，让我们做一个测试：按下 Ctrl+C 来关闭服务器。</p>\n<p>现在让我们在关闭http-server进程后点击刷新：您可能会惊讶于应用程序仍在运行，我们得到了完全相同的屏幕！</p>\n<p>在控制台上，我们会发现以下消息：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">An unknown error occurred when fetching the script.\nngsw-worker.js Failed to load resource: net::ERR_CONNECTION_REFUSED</code></pre>\n\n<p>唯一尝试从网络获取的文件是 Service Worker 文件本身，这是正常的。</p>\n<h3 id=\"版本管理\"><a href=\"#版本管理\" class=\"headerlink\" title=\"版本管理\"></a>版本管理</h3><p>应用程序将静态文件都缓存到本存在一定的风险，当更新了代码发布了新版本的时候还是会从本地读取。</p>\n<p>假设我们对应用程序进行了一些小的更改，例如编辑styles.scss文件中的全局样式。在再次运行生产构建之前，让我们保留 之前的版本ngsw.json，以便我们可以看到发生了什么变化。</p>\n<p>现在让我们再次运行生产构建，并比较生成的ngsw.json文件：<br><img src=\"http://jsnext.icu/20211114235245.png\" alt=\"4\"></p>\n<p>正如我们所看到的，构建输出中唯一改变的是 CSS 包，所有剩余的文件都没有改变，除了index.html（加载新包的地方）</p>\n<h4 id=\"Angular-Service-Worker-如何更新版本\"><a href=\"#Angular-Service-Worker-如何更新版本\" class=\"headerlink\" title=\"Angular Service Worker 如何更新版本\"></a>Angular Service Worker 如何更新版本</h4><p>每次用户重新加载应用程序时，Angular Service Worker 都会检查ngsw.json服务器上是否有可用的新文件。</p>\n<p>这是为了与标准 Service Worker 行为保持一致，并避免应用程序的陈旧版本长时间运行。陈旧的版本可能包含错误甚至完全损坏，因此必须经常检查服务器上是否有新的应用程序版本可用。</p>\n<p>在我们的例子中，ngsw.json将比较文件的旧版本和新版本，并在后台下载并安装新的 CSS 包。</p>\n<p>下次用户重新加载页面时，将显示新的应用程序版本！</p>\n<h4 id=\"通知用户有新版本可用\"><a href=\"#通知用户有新版本可用\" class=\"headerlink\" title=\"通知用户有新版本可用\"></a>通知用户有新版本可用</h4><p>对于用户可能已打开数小时的长时间运行的 SPA 应用程序，我们可能希望定期检查服务器上是否有应用程序的新版本并将其安装在后台。</p>\n<p>为了检查新版本是否可用，我们可以使用该SwUpdate服务及其checkForUpdate()方法。</p>\n<p>但一般来说，checkForUpdate()手动调用不是必需的，因为 Angular Service Worker 会ngsw.json在每次完整的应用程序重新加载时寻找新版本，以与标准 Service Worker 生命周期保持一致。</p>\n<p>我们可以通过使用availableObservable来要求在新版本可用时得到通知SWUpdate，然后通过对话框询问用户是否想要获取新版本：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">@Component(&#123;\n  selector: &#39;app-root&#39;,\n  templateUrl: &#39;.&#x2F;app.component.html&#39;,\n  styleUrls: [&#39;.&#x2F;app.component.css&#39;]\n&#125;)\nexport class AppComponent  implements OnInit &#123;\n\n    constructor(private swUpdate: SwUpdate) &#123;\n    &#125;\n\n    ngOnInit() &#123;\n\n        if (this.swUpdate.isEnabled) &#123;\n\n            this.swUpdate.available.subscribe(() &#x3D;&gt; &#123;\n\n                if(confirm(&quot;New version available. Load New Version?&quot;)) &#123;\n\n                    window.location.reload();\n                &#125;\n            &#125;);\n        &#125;        \n    &#125;\n&#125;</code></pre>\n<p>当新的应用程序版本部署在服务器上时，让我们分解一下这段代码会发生什么：</p>\n<ul>\n<li>新文件现在在服务器上可用，例如新的 CSS 或 Js </li>\n<li>ngsw.json服务器上有一个新文件，其中包含有关新应用程序版本的信息：加载哪些文件，何时加载等。</li>\n</ul>\n<p>这是正常的，因为用户仍然有一个 Service Worker 在浏览器中运行，它仍然为缓存存储中的所有文件提供服务，并且完全绕过网络。</p>\n<p>但是，Angular Service Worker 也会调用服务器以查看是否有新的ngsw.json，并ngsw.json在后台触发加载文件中提到的任何新文件。</p>\n<p>加载新应用程序版本的所有文件后，Angular Service Worker 将发出该available事件，这意味着新版本的应用程序可用。然后用户将看到以下内容：<br><img src=\"http://jsnext.icu/20211120535245.png\" alt=\"5\"></p>\n<p>如果用户单击<code>Ok</code>，则将重新加载完整的应用程序并显示新版本。请注意，如果我们没有向用户显示此对话框，则用户仍然会在下次重新加载时看到新版本。</p>\n"},{"title":"JavaScript 中的事件循环机制","date":"2021-10-12T14:08:12.000Z","_content":"\nJavaScript 是单线程的，一次只能处理一个任务。在正常的环境下这没有什么问题，但是试想一下你正在运行一个需要30秒的任务，在该任务期间我们需要等待30秒才能做其他事情（ JavaScript 默认是浏览器的主线程运行的，所以整个UI都会卡住，无响应）\n\n幸运的是，浏览器为我们提供了一些 JavaScript 引擎本身不提供的功能：Web API。这包括 DOM API、setTimeout、HTTP 请求等。这可以帮助我们创建一些异步的、非阻塞的行为。\n\n当我们调用一个函数时，它会被添加到称为执行栈中。执行栈是 JS 引擎的一部分，这不是特定于浏览器的。它是一个堆栈，意思是先入后出。当一个函数返回一个值时，它会出栈。\n\n![gif](http://jsnext.icu/gid1%20%281%29.gif)\n\nrespond函数返回一个setTimeout函数。在setTimeout由Web API提供给我们：它让我们的任务延迟执行，而不会阻塞主线程。我们传递给setTimeout函数的是一个回调函数，`() => { return 'Hey'}`被添加到 Web API 中。与此同时，setTimeout函数和响应函数从堆栈中弹出，它们都返回了它们的值。\n\n![gif](/img/gif2.1.gif)\n\n在 Web API 中，计时器运行的时间与我们传递给它的第二个参数一样长，即 1000 毫秒。回调不会立即添加到调用堆栈中，而是传递给事件队列。\n\n![gif](/img/gif3.1.gif)\n\n回调函数并不是在 1000 毫秒后被添加到执行栈中（从而返回一个值）。它只是在 1000 毫秒后添加到事件队列中。函数的执行必须排队！这可能是令人疑惑的部分\n\n是时候让事件循环完成它唯一的任务：将事件队列与执行栈连接起来！如果执行栈为空，那么如果所有先前调用的函数都返回了它们的值并出栈，则队事件列中的第一项将添加到执行栈中。在这种情况下，没有调用其他函数，这意味着当回调函数成为队列中的第一项时，执行栈是空的。\n\n![gif](/img/gif4.gif)\n\n回调被添加到执行栈中，被调用，并返回一个值，然后出栈。\n\n![gif](/img/gif5.gif)\n\n执行以下代码，想想整个处理过程是怎样的\n\n```javascript\nconst foo = () => console.log(\"First\");\nconst bar = () => setTimeout(() => console.log(\"Second\"), 500);\nconst baz = () => console.log(\"Third\");\n\nbar();\nfoo();\nbaz();\n```\n\n让我们快速看看在浏览器中运行这段代码时发生了什么：\n\n![gif](/img/gif14.1.gif)\n\n- 调用bar。 bar返回一个setTimeout函数。\n- 我们传递给的回调函数被添加到 Web API、setTimeout函数并bar从执行栈中弹出。\n- 计时器运行，同时foo被调用和输出`First`。foo返回（`undefined`），baz被调用，回调函数被添加到事件队列中。\n- baz输出`Third`。事件循环在baz返回后看到执行栈为空，之后回调函数被添加到执行栈中。\n- 回调函数被执行，输出`Second`。\n","source":"_posts/eventLoop.md","raw":"---\ntitle: JavaScript 中的事件循环机制\ndate: 2021-10-12 22:08:12\ntags:\n---\n\nJavaScript 是单线程的，一次只能处理一个任务。在正常的环境下这没有什么问题，但是试想一下你正在运行一个需要30秒的任务，在该任务期间我们需要等待30秒才能做其他事情（ JavaScript 默认是浏览器的主线程运行的，所以整个UI都会卡住，无响应）\n\n幸运的是，浏览器为我们提供了一些 JavaScript 引擎本身不提供的功能：Web API。这包括 DOM API、setTimeout、HTTP 请求等。这可以帮助我们创建一些异步的、非阻塞的行为。\n\n当我们调用一个函数时，它会被添加到称为执行栈中。执行栈是 JS 引擎的一部分，这不是特定于浏览器的。它是一个堆栈，意思是先入后出。当一个函数返回一个值时，它会出栈。\n\n![gif](http://jsnext.icu/gid1%20%281%29.gif)\n\nrespond函数返回一个setTimeout函数。在setTimeout由Web API提供给我们：它让我们的任务延迟执行，而不会阻塞主线程。我们传递给setTimeout函数的是一个回调函数，`() => { return 'Hey'}`被添加到 Web API 中。与此同时，setTimeout函数和响应函数从堆栈中弹出，它们都返回了它们的值。\n\n![gif](/img/gif2.1.gif)\n\n在 Web API 中，计时器运行的时间与我们传递给它的第二个参数一样长，即 1000 毫秒。回调不会立即添加到调用堆栈中，而是传递给事件队列。\n\n![gif](/img/gif3.1.gif)\n\n回调函数并不是在 1000 毫秒后被添加到执行栈中（从而返回一个值）。它只是在 1000 毫秒后添加到事件队列中。函数的执行必须排队！这可能是令人疑惑的部分\n\n是时候让事件循环完成它唯一的任务：将事件队列与执行栈连接起来！如果执行栈为空，那么如果所有先前调用的函数都返回了它们的值并出栈，则队事件列中的第一项将添加到执行栈中。在这种情况下，没有调用其他函数，这意味着当回调函数成为队列中的第一项时，执行栈是空的。\n\n![gif](/img/gif4.gif)\n\n回调被添加到执行栈中，被调用，并返回一个值，然后出栈。\n\n![gif](/img/gif5.gif)\n\n执行以下代码，想想整个处理过程是怎样的\n\n```javascript\nconst foo = () => console.log(\"First\");\nconst bar = () => setTimeout(() => console.log(\"Second\"), 500);\nconst baz = () => console.log(\"Third\");\n\nbar();\nfoo();\nbaz();\n```\n\n让我们快速看看在浏览器中运行这段代码时发生了什么：\n\n![gif](/img/gif14.1.gif)\n\n- 调用bar。 bar返回一个setTimeout函数。\n- 我们传递给的回调函数被添加到 Web API、setTimeout函数并bar从执行栈中弹出。\n- 计时器运行，同时foo被调用和输出`First`。foo返回（`undefined`），baz被调用，回调函数被添加到事件队列中。\n- baz输出`Third`。事件循环在baz返回后看到执行栈为空，之后回调函数被添加到执行栈中。\n- 回调函数被执行，输出`Second`。\n","slug":"eventLoop","published":1,"updated":"2021-11-22T16:10:10.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwav7x5g0000fgvjhtehajv4","content":"<p>JavaScript 是单线程的，一次只能处理一个任务。在正常的环境下这没有什么问题，但是试想一下你正在运行一个需要30秒的任务，在该任务期间我们需要等待30秒才能做其他事情（ JavaScript 默认是浏览器的主线程运行的，所以整个UI都会卡住，无响应）</p>\n<p>幸运的是，浏览器为我们提供了一些 JavaScript 引擎本身不提供的功能：Web API。这包括 DOM API、setTimeout、HTTP 请求等。这可以帮助我们创建一些异步的、非阻塞的行为。</p>\n<p>当我们调用一个函数时，它会被添加到称为执行栈中。执行栈是 JS 引擎的一部分，这不是特定于浏览器的。它是一个堆栈，意思是先入后出。当一个函数返回一个值时，它会出栈。</p>\n<p><img src=\"http://jsnext.icu/gid1%20%281%29.gif\" alt=\"gif\"></p>\n<p>respond函数返回一个setTimeout函数。在setTimeout由Web API提供给我们：它让我们的任务延迟执行，而不会阻塞主线程。我们传递给setTimeout函数的是一个回调函数，<code>() =&gt; &#123; return &#39;Hey&#39;&#125;</code>被添加到 Web API 中。与此同时，setTimeout函数和响应函数从堆栈中弹出，它们都返回了它们的值。</p>\n<p><img src=\"/img/gif2.1.gif\" alt=\"gif\"></p>\n<p>在 Web API 中，计时器运行的时间与我们传递给它的第二个参数一样长，即 1000 毫秒。回调不会立即添加到调用堆栈中，而是传递给事件队列。</p>\n<p><img src=\"/img/gif3.1.gif\" alt=\"gif\"></p>\n<p>回调函数并不是在 1000 毫秒后被添加到执行栈中（从而返回一个值）。它只是在 1000 毫秒后添加到事件队列中。函数的执行必须排队！这可能是令人疑惑的部分</p>\n<p>是时候让事件循环完成它唯一的任务：将事件队列与执行栈连接起来！如果执行栈为空，那么如果所有先前调用的函数都返回了它们的值并出栈，则队事件列中的第一项将添加到执行栈中。在这种情况下，没有调用其他函数，这意味着当回调函数成为队列中的第一项时，执行栈是空的。</p>\n<p><img src=\"/img/gif4.gif\" alt=\"gif\"></p>\n<p>回调被添加到执行栈中，被调用，并返回一个值，然后出栈。</p>\n<p><img src=\"/img/gif5.gif\" alt=\"gif\"></p>\n<p>执行以下代码，想想整个处理过程是怎样的</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const foo &#x3D; () &#x3D;&gt; console.log(&quot;First&quot;);\nconst bar &#x3D; () &#x3D;&gt; setTimeout(() &#x3D;&gt; console.log(&quot;Second&quot;), 500);\nconst baz &#x3D; () &#x3D;&gt; console.log(&quot;Third&quot;);\n\nbar();\nfoo();\nbaz();</code></pre>\n\n<p>让我们快速看看在浏览器中运行这段代码时发生了什么：</p>\n<p><img src=\"/img/gif14.1.gif\" alt=\"gif\"></p>\n<ul>\n<li>调用bar。 bar返回一个setTimeout函数。</li>\n<li>我们传递给的回调函数被添加到 Web API、setTimeout函数并bar从执行栈中弹出。</li>\n<li>计时器运行，同时foo被调用和输出<code>First</code>。foo返回（<code>undefined</code>），baz被调用，回调函数被添加到事件队列中。</li>\n<li>baz输出<code>Third</code>。事件循环在baz返回后看到执行栈为空，之后回调函数被添加到执行栈中。</li>\n<li>回调函数被执行，输出<code>Second</code>。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>JavaScript 是单线程的，一次只能处理一个任务。在正常的环境下这没有什么问题，但是试想一下你正在运行一个需要30秒的任务，在该任务期间我们需要等待30秒才能做其他事情（ JavaScript 默认是浏览器的主线程运行的，所以整个UI都会卡住，无响应）</p>\n<p>幸运的是，浏览器为我们提供了一些 JavaScript 引擎本身不提供的功能：Web API。这包括 DOM API、setTimeout、HTTP 请求等。这可以帮助我们创建一些异步的、非阻塞的行为。</p>\n<p>当我们调用一个函数时，它会被添加到称为执行栈中。执行栈是 JS 引擎的一部分，这不是特定于浏览器的。它是一个堆栈，意思是先入后出。当一个函数返回一个值时，它会出栈。</p>\n<p><img src=\"http://jsnext.icu/gid1%20%281%29.gif\" alt=\"gif\"></p>\n<p>respond函数返回一个setTimeout函数。在setTimeout由Web API提供给我们：它让我们的任务延迟执行，而不会阻塞主线程。我们传递给setTimeout函数的是一个回调函数，<code>() =&gt; &#123; return &#39;Hey&#39;&#125;</code>被添加到 Web API 中。与此同时，setTimeout函数和响应函数从堆栈中弹出，它们都返回了它们的值。</p>\n<p><img src=\"/img/gif2.1.gif\" alt=\"gif\"></p>\n<p>在 Web API 中，计时器运行的时间与我们传递给它的第二个参数一样长，即 1000 毫秒。回调不会立即添加到调用堆栈中，而是传递给事件队列。</p>\n<p><img src=\"/img/gif3.1.gif\" alt=\"gif\"></p>\n<p>回调函数并不是在 1000 毫秒后被添加到执行栈中（从而返回一个值）。它只是在 1000 毫秒后添加到事件队列中。函数的执行必须排队！这可能是令人疑惑的部分</p>\n<p>是时候让事件循环完成它唯一的任务：将事件队列与执行栈连接起来！如果执行栈为空，那么如果所有先前调用的函数都返回了它们的值并出栈，则队事件列中的第一项将添加到执行栈中。在这种情况下，没有调用其他函数，这意味着当回调函数成为队列中的第一项时，执行栈是空的。</p>\n<p><img src=\"/img/gif4.gif\" alt=\"gif\"></p>\n<p>回调被添加到执行栈中，被调用，并返回一个值，然后出栈。</p>\n<p><img src=\"/img/gif5.gif\" alt=\"gif\"></p>\n<p>执行以下代码，想想整个处理过程是怎样的</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const foo &#x3D; () &#x3D;&gt; console.log(&quot;First&quot;);\nconst bar &#x3D; () &#x3D;&gt; setTimeout(() &#x3D;&gt; console.log(&quot;Second&quot;), 500);\nconst baz &#x3D; () &#x3D;&gt; console.log(&quot;Third&quot;);\n\nbar();\nfoo();\nbaz();</code></pre>\n\n<p>让我们快速看看在浏览器中运行这段代码时发生了什么：</p>\n<p><img src=\"/img/gif14.1.gif\" alt=\"gif\"></p>\n<ul>\n<li>调用bar。 bar返回一个setTimeout函数。</li>\n<li>我们传递给的回调函数被添加到 Web API、setTimeout函数并bar从执行栈中弹出。</li>\n<li>计时器运行，同时foo被调用和输出<code>First</code>。foo返回（<code>undefined</code>），baz被调用，回调函数被添加到事件队列中。</li>\n<li>baz输出<code>Third</code>。事件循环在baz返回后看到执行栈为空，之后回调函数被添加到执行栈中。</li>\n<li>回调函数被执行，输出<code>Second</code>。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}